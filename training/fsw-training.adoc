FSW Training
============
:author: Jorge Morales 
:email: <jmorales@redhat.com>
:description: FSW training
:revdate: 2014-07-17
:revnumber: 0.1
:icons: font
:imagesdir: ./images
:figure-caption!:
:deckjs_theme: beamer
// web-2.0
//:deckjs_transition: horizontal-slide
//:pygments:
//:pygments_style: native
:scrollable:
// :linkcss: ./css/redhat.css
//:count_nested:

== FSW from the Red Hat website

[quote, Red Hat website, http://www.redhat.com/es/technologies/jboss-middleware/fuse-service-works]
____
Red Hat® JBoss® Fuse Service Works is a platform that creates reusable, changeable, and flexible business services that hide the complexity of connecting to different applications in your enterprise. It sets the stage for faster and easier cloud apps, mobile apps, and business process development projects.

JBoss Fuse Service Works combines technical innovations from leading open source projects with the experience and support you expect from a world-class software provider.

image::fsw/FSW_benefits.png[FSW benefits]
____

== FSW from the JBoss.org

[quote, JBoss.org, http://www.jboss.org/products/fsw/overview/]
____
An open source service design, development and integration platform that speeds up cloud integration.

JBoss Fuse Service Works is Red Hat’s middleware solution for application integration, messaging, SOA, and service governance requirements. It combines the core ESB technology from JBoss Fuse and technical innovations from popular open source communities like SwitchYard and Overlord.
____

== From the official documentation

[quote, Red Hat product documentation, https://access.redhat.com/documentation/en-US/Red_Hat_JBoss_Fuse_Service_Works/6/html/User_Guide/chap-Preface.html]
____
Red Hat JBoss Fuse Service Works is a platform for developing enterprise application integration (EAI) and service-oriented architecture (SOA) solutions. It consists of a service component framework, business rules/complex event processing, life-cycle governance, runtime governance and process automation. It is built on the same core as JBoss Fuse with enterprise messaging, Camel and CXF so, therefore, users can use it to design, deploy, integrate and orchestrate business services.
____


== FSW Core Capabilities
The benefits of using Red Hat JBoss Fuse Service Works include the following:

Enterprise Integration Pattern (EIP) Based Development:: The versatile EIP framework is implemented in routing and transformation processes for faster and more efficient integration solutions.
High Performance Messaging:: A high performance messaging broker supports messaging patterns such as publish-subscribe, point-to-point and store-forward, and multiple cross language clients.
Service Development:: The web services framework exposes integration assets as services and calls external services, supporting all major web services standards. It also supports RESTful calls.
Structured Service Development:: A lightweight service development framework provides full lifecycle support for developing, deploying, and managing service-based applications.
Automatable Registry with Workflow:: Manage the lifecycle of services from design, development and deployment by defining, exposing and enforcing rules or policies.
Business Transaction Monitoring:: Capture service activity information, define and collect metrics, and define alerts and SLAs.
Report a bug:: (Just kidding)

=== FSW as System Integration
Integrating your major business systems into a cohesive infrastructure can be a challenge, especially when you have legacy applications. Red Hat JBoss Fuse Service Works has a number of ways enable you to integrate both new and legacy applications. Development is simplified with a transparent, lightweight service framework which uses EIP technology. This allows developers to focus on higher order concepts while still working with familiar technologies such as Apache Camel, BPEL, BPMN or POJOs. To reduce the operational costs of production and maintenance, the platform utilizes automatable, content-aware repository and service activity monitoring. These support the entire service lifecycle and development, QA and production teams with run-time and design-time visibility, monitoring and alerting.

== What is integration

[quote, Wikipedia, http://en.wikipedia.org/wiki/Systems_integration]
____
System integration is defined as the process of bringing together the component subsystems into one system and ensuring that the subsystems function together as a system.

The system integrator brings together discrete systems utilizing a variety of techniques such as computer networking, enterprise application integration, business process management or manual programming.
____

== What is applications integration

[quote, MuleSoft, https://www.mulesoft.com/resources/esb/applications-integration]
____
Applications integration (or enterprise application integration) is the sharing of processes and data among different applications in an enterprise. For both small and large organizations alike, it has become a mission-critical priority to connect disparate applications and leverage application collaboration across the enterprise in order to improve overall business efficiency, enhance scalability, and reduce IT costs.
____

== What is governance

[quote, Wikipedia, http://en.wikipedia.org/wiki/Governance]
____
Governance refers to "all processes of governing, whether undertaken by a government, market or network, whether over a family, tribe, formal or informal organization or territory and whether through laws, norms, power or language." It relates to processes and decisions that seek to define actions, grant power and verify performance.
____

== Training contents

* SwitchYard
* RTGov
* DTGov

== FSW Overview - Components

image:fsw/fsw_component_overview.png[FSW component overview]

== FSW Overview - Layers

image:fsw/fsw_layers.png[FSW layers]

== FSW Overview - Architecture 

image:fsw/fsw_architecture.png[FSW architecture]

== SwitchYard

image::switchyard/switchyard.png[] 

* SCA (Service, component, reference, binding)
* Components (Service implementations)
* Bindings (Gateways)
* Transformations (Java, JAXB, JSON, Smooks, XSLT, ...)
* Validations (Java validations, XML Validation)
* Properties
* Policies (transaction, )
* Security
* Clustering
* RemoteInvoker
* Serialization
* Extensions 

== SwitchYard - SCA

____
SwitchYard is a component-based *development framework* focused on building *structured*, *maintainable services* and *applications* using the concepts and best practices of SOA. It works with Apache Camel to provide a *fast*, *simple*, *flexible* integration runtime with *comprehensive* connectivity and transports. A *uniform* application model *augments* Apache Camel, *joining* Java EE, BPM, rules, orchestration, and routing into a *cohesive* development model and runtime. 

Common functionality and cross-cutting concerns - validation, transformation and policy - are isolated from business logic and handled declaratively. This ensures *consistency* and *eliminates duplication*, offering developers a clear view of the structure and relationships of services in an integration application.
____

== SwitchYard - SCA

image::switchyard/sca/app.jpg[SwitchYard application]

== Composite
A composite is displayed as a light blue rectangle and represents the boundary between what's inside your application and what's outside your application. A SwitchYard application consists of exactly one composite that has a name and a targetNamespace. The targetNamespace value is important as it allows names defined locally in the application (e.g. service names) to be qualified and unique within a SwitchYard runtime.

== Composite
image::switchyard/sca/composite.jpg[composite]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
</sca:composite>
----

== Component
A component is a modular container for application logic and consists of the following:

* 0 or 1 component service definitions
* 0 to many component reference definitions
* 1 implementation

Services and references allow a component to interact with other components, while the implementation provides the actual logic for providing and/or consuming services.

== Component
image::switchyard/sca/component.jpg[component]

[source,xml]
----
<sca:component name="Routing">
</sca:component>
----

== Implementation
An implementation acts as the 'brain' of a service component and it is how implement your application logic. The following implementation options are available:

* *Bean*: allows a CDI Bean to consume or provide services using annotations.
* *Camel*: EIP-style routing and service composition using the XML or Java DSL in Apache Camel.
* *BPMN 2*: service orchestration and human task integration expressed as BPMN 2 and executed using jBPM.
* *BPEL Process*: web service orchestration using the OASIS Business Process Execution Language.
* *Rules*: decision services based on Drools.

Implementations are private to a component, which means external consumers and providers are not aware of the details of a component's implementation (implementation-hiding).  All interactions with other components within an application and with external services are handled through component services and references.

== Implementation
image::switchyard/sca/implementations.jpg[implementation]

[source,xml]
----
<sca:component name="Routing">
   <camel:implementation.camel>
      <camel:xml path="RoutingService.xml"/>
   </camel:implementation.camel>
</sca:component>
----

== Component Service
A component service is used to expose the functionality of an implementation as a service. All component services have a contract, which can be a Java interface, WSDL portType definition, or a set of named data types (interface.esb). Component services are private to an application, which means a component service can only be invoked by other components in the same application. In order to expose a component service to consumers external to the application, a component service can be 'promoted' to a composite service. A component service can be promoted multiple times to create different composite services.

== Component Service
image::switchyard/sca/component-service.jpg[Component service]

[source,xml]
----
<sca:component name="Routing">
   <camel:implementation.camel>
      <camel:xml path="route.xml"/>
   </camel:implementation.camel>
   <sca:service name="ServiceA">
      <sca:interface.java interface="org.example.ServiceA"/>
   </sca:service>
</sca:component>
----

== Composite Service
A composite service represents an application service which is visible to other applications. A composite service can only be realized by promoting a component service within the application. The name and the interface of the composite service can be different from the component service. If the interface, or contract, of the composite service is different from the component service, be aware that a transformation may be required to map between the types defined in each interface. In our example application, the component service has a Java interface while the composite service has a WSDL interface. This means we would need to declare a transformer which maps between XML and Java to resolve the data type mismatch.

== Composite Service
image::switchyard/sca/composite-service.jpg[Composite service]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
   <sca:service name="ServiceA" promote="Routing/ServiceA">
      <sca:interface.wsdl interface="ServiceA.wsdl#wsdl.porttype(ServiceAPortType)"/>
   </sca:service>
</sca:composite>
----

== Service Binding
A service binding is used to define an access method for a composite service. Composite services can have multiple bindings, which allows a single service to be accessed in different ways. In most cases, a service binding represents a protocol/transport adapter (e.g. SOAP, JMS, REST). An important exception to this rule is the SCA binding, which allows services across applications in the same runtime to be wired together in memory. Regardless of the underlying binding details, a binding must always be used to facilitate inter-application communication in SwitchYard.

== Service Binding
image::switchyard/sca/service-binding.jpg[Service binding]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
   <sca:service name="ServiceA" promote="Routing/ServiceA">
      <sca:interface.wsdl interface="ServiceA.wsdl#wsdl.porttype(ServiceAPortType)"/>
      <soap:binding.soap>
        <soap:wsdl>ServiceA.wsdl</soap:wsdl>
      </soap:binding.soap>
   </sca:service>
</sca:composite>
----

== Component Reference
A component reference allows a component to consume other services. A component reference can be wired to a service offered by another component in the same application or it can be wired to services outside the application via a composite reference. Similar to component services, all component references have a contract with allows a component to invoke services without knowing implementation or binding details. The picture below shows an example of wiring a reference on the Routing component to a service offered by the Bean component.

== Component Reference
image::switchyard/sca/component-reference.jpg[Component reference]

[source,xml]
----
<sca:component name="Routing">
   <camel:implementation.camel>
      <camel:xml path="route.xml"/>
   </camel:implementation.camel>
   <sca:service name="ServiceA">
      <sca:interface.java interface="org.example.ServiceA"/>
   </sca:service>
   <sca:reference name="ServiceC">
      <sca:interface.java interface="org.example.ServiceC"/>
   </sca:reference>
</sca:component>
----

== Composite Reference
A composite reference allows a component reference to be wired to a service outside the application. Similar to composite services, bindings are used with composite references to specify the communication method for invoking the external service.

== Composite Reference
image::switchyard/sca/composite-reference.jpg[Composite reference]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
   <sca:reference name="ReferenceB" multiplicity="0..1" promote="Routing/ServiceB">
      <sca:interface.java interface="org.example.ServiceB"/>
   </sca:reference>
</sca:composite>
----

== Reference Bindings
A reference binding is used to define an access method for an external service via a composite reference. Unlike service bindings, there can only be one binding for each composite reference. The set of bindings available for references is identical to the set of bindings available for services, although the configuration values for a given binding may be different depending on whether it's used as a service binding or a reference binding.

== Reference Bindings
image::switchyard/sca/reference-binding.jpg[Reference binding]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
   <sca:reference name="ReferenceB" multiplicity="0..1" promote="Routing/ServiceB">
      <sca:interface.java interface="org.example.ServiceB"/>
         <jms:binding.jms>
         <jms:queue>MyQueue</jms:queue>
         <jms:connectionFactory>#ConnectionFactory</jms:connectionFactory>
      </jms:binding.jms>
   </sca:reference>
</sca:composite>
----

== SCA terms summary

image::switchyard/sca/sca_summary.png[SCA Summary]

== Create an application

image::switchyard/service_creation/1.png[To create this service]

== Create a composite

image::switchyard/service_creation/2.png[Create a composite]

== Add a component

image::switchyard/service_creation/3.png[Add a component]

== Add more components and link them

image::switchyard/service_creation/4.png[Add more components and link them]

== Even more components

image::switchyard/service_creation/5.png[Even more components]

== Expose/call your service

image::switchyard/service_creation/6.png[Expose/call your service]

== Invoke/Call external applications (references)

image::switchyard/service_creation/1.png[Call external applications]

== Configure every declarative aspect

* Properties
* Policies
* Transformations
* Validation
* ...

== Components - What we have
 **  Component contract interfaces: wsdl, java, esb
 **  Bean (Java)
 **  Camel (java, xml)
 **  BPEL (XPath functions)
 **  BPM
 **  Rules (Knowledge services)

== Contracts

Every service needs to have it's contract defined (API).

This contracts can be defined in on of 3 ways:

* Java 
* WSDL
* SOA

NOTE: SwitcyYard require a one parameter per method in the contract definition

== Java contract

.Definition
image::switchyard/contracts/java_contract.png[Java contract]

.Implementation
image::switchyard/contracts/java_contract_impl.png[Java contract Implementation]

== WSDL contract

.Definition
image::switchyard/contracts/wsdl_contract.png[WSDL contract]

.Implementation
image::switchyard/contracts/wsdl_contract_impl.png[WSDL contract Implementation]

== ESB contract

.Definition and implementation
image::switchyard/contracts/esb_contract.png[ESB contract]

== Bean Component
The Bean Component is a pluggable container in SwitchYard which allows Java classes (or beans) to provide and consume services. This means that you can implement a service by simply annotating a Java class. It also means you can consume a service by injecting a reference to that service directly into your Java class

image::switchyard/components/bean/bean_component.png[Bean component]

== Creating a Bean service
To create a new Bean service you only need a few pieces of information:

* *Name*: the name of the Java class for your bean service.
* *Service Name*: the name of the service your bean will provide.
* *Interface*: the contract for the service being provided.  Java is the only valid interface type for bean services.

== Creating a Bean service
image::switchyard/components/bean/new-bean.jpg[New bean component]

== Creating a Bean service

[source,java]
----
package com.example.switchyard.docs;
 
import org.switchyard.component.bean.Service;
 
@Service(Example.class)
public class ExampleBean implements Example {
 
}
----

The @Service annotation allows the SwitchYard CDI Extension to discover your bean at runtime and register it as a service. The value of the annotatio represents the service contract for the service. 

 Every bean service must have an @Service annotation with a value identifying the service interface for the service.
 
== Consuming a Bean service
In addition to providing a service in SwitchYard, beans can also consume other services. These services can be provided in the same application by other implementations, or they could be wired to gateway bindings to invoke services over JMS, SOAP, FTP, etc. The SwitchYard runtime handles the resolution of the service reference to a concrete service, allowing your service logic to remain blissfully ignorant. Invocations made through this reference are routed through the SwitchYard exchange mechanism.

[source,java]
----
@Inject @Reference
private SimpleService service;

public void consumeSomeService(String consumerName) {
   service.sayHello("Hello " + consumerName);
}
----

== Consuming a Bean service
By default, SwitchYard expects a service reference to be declared with a name which matches the Java type used for the reference. In the event where the service reference name is different from the type name of the contract, the @Reference annotation can accept a service name

[source,java]
----
@Inject @Reference("urn:com.example.services:SimpleService:1.0")
private SimpleService service;

public void consumeSomeService(String consumerName) {
   service.sayHello("Hello " + consumerName);
}
----

== Consuming a Bean service

image::switchyard/components/bean/consume_service_1.png[]

== Consuming a Bean service

image::switchyard/components/bean/consume_service_2.png[]

== Consuming a Bean service

image::switchyard/components/bean/consume_service_3.png[]

== Consuming a Bean service

image::switchyard/components/bean/consume_service_4.png[]

== Reference Invoker
The default behavior of @Reference is to inject a reference using the Java interface of the reference contract. This is adequate for most cases, but it does not allow you to access SwitchYard API constructs like the Message and Context interfaces. 

If you need to access to an attachment or a context property when invoking a reference from a Bean service, then you will want to use a *ReferenceInvoker*. To use a ReferenceInvoker, all you need to do is _replace the service contract interface type with a ReferenceInvoker type and SwitchYard will automatically inject the correct instance_.

[source,java]
----
@Inject @Reference("urn:com.example.services:SimpleService:1.0")
private ReferenceInvoker service;

public void consumeSomeService(String consumerName) {
   service.newInvocation("sayHello")
      .setProperty("myHeader", "myValue")
      .invoke(consumerName);
}
----

 Note how the ReferenceInvoker instance is used to create a ReferenceInvocation using the newInvocation() method. A new instance of ReferenceInvocation should be created each time you want to invoke a service using ReferenceInvoker.

== Camel Component
Camel services allow you to leverage the core routing engine inside of Apache Camel to route between services in SwitchYard. All of the EIP and core routing support in Camel is available to your service implementation. Each Camel route is exposed as a service within SwitchYard, which means it has a well-defined contract and can be injected into any other service in the runtime.

There are 2 implementations:

* Java DSL
* XML DSL

== Camel Component Tips

* There is only one route per service. (More routes can be created, only one component entry point)
* The consumer or "from" endpoint in a route is always a "switchyard" endpoint and the endpoint name must equal the service name.  This is default behavior in the tooling.
* To consume other services from within your route, only use "switchyard" consumer (i.e. "to") endpoints. This keeps your routing logic independent of the binding details for consumed services.

 These are tips and behaviour can be modify to NOT comply with above tips 

== Creating a Camel Service in Java DSL

image::switchyard/components/camel/new_camel_java_service.png[New Camel Java Service]

== Creating a Camel Service in Java DSL

[source,java]
----
package com.example.switchyard.docs;
 
import org.apache.camel.builder.RouteBuilder;
 
public class CamelServiceRoute extends RouteBuilder {
    /**
     * The Camel route is configured via this method.  The from:
     * endpoint is required to be a SwitchYard service.
     */
    public void configure() {
        // TODO Auto-generated method stub
        from("switchyard://Example").log(
                "Received message for 'Example' : ${body}");
    }
}
----

 There are no SwitchYard-specific classes or APIs used for Java DSL route; the route class is identical in signature to what you would use with Apache Camel directly.

== Creating a Camel Service in XML DSL

image::switchyard/components/camel/new_camel_xml_service.png[New Camel XML Service]

== Creating a Camel Service in XML DSL

[source,xml]
----
<?xml version="1.0" encoding="ASCII"?>
<route xmlns="http://camel.apache.org/schema/spring">
   <from uri="switchyard://Example"/>
   <log message="Example - message received: ${body}"/>
</route>
----

 The XML routing syntax is identical to what you would use with Apache Camel directly and conforms to the Camel schema for <route> definition

== Drawbacks in Camel Service in XML DSL

NOTE: As of FSW 6.0 there is no access to Camel Context from within the route xml definition file, so it is not suitable for defining namespaces,... or anything that get's registered into the Camel Context.

== Consuming services from Camel routes
Invoking another service from within your Camel route can be done by using the SwitchYard producer endpoint (switchyard://) within your route.  Endpoint configuration is very straightforward:

[source,java]
----
switchyard://<service-name>[?operationName=<operation-name>]
----

* *service-name*: name of the SwitchYard service. This value needs to match the name of a service reference defined on the service component for the route.
* *operation-name*: name of the service operation to be invoked. This is only used on references and is optional if the target service only has a single operation.

image::switchyard/composite_overview.png[Composite overview]

== Scripting languages in Camel
Because of 3rd party dependencies, SwitchYard supports only following languages:

* BeanShell
* JavaScript
* Groovy
* Ruby
* Python

 Inside your script you will have access to predefined variables like request, response or exchange which will let you generate response.

[source,java]
----
public class ScriptingBuilder extends RouteBuilder {
 
    public void configure() {
        from("switchyard://Inbound")
            .filter().javaScript("request.getHeader('myHeader') != null")
                .to("switchyard://Outbound");
    }
}
----

[source,java]
----
public class ScriptingImplementationBuilder extends RouteBuilder {
 
    public void configure() {
        from("switchyard://Inbound")
            .transform().groovy("classpath:script.groovy"); // classpath resource
 
        from("switchyard://InboundBsh")
            .transform().language("beanshell", "file:script.bsh"); // file system resource
    }
}
----

== Camel CDI Integration

SwitchYard integrates the CDI Bean Manager with the Camel Bean Registry to allow you to reference CDI Beans in your Camel routes. Any Java class annotated with @Named in your application will be available through Camel's Bean registry.

[source,java]
----
@Named("StringSupport")
@ApplicationScoped
public class StringUtil {
 
    public String trim(String string) {
        return string.trim();
    }
}
----

[source,java]
----
public class ExampleBuilder extends RouteBuilder {
 
    public void configure() {
        from("switchyard://ExampleBuilder")
            .split(body(String.class).tokenize("\n"))
            .filter(body(String.class).startsWith("sally:"))
            .to("bean:StringSupport");
    }
}
----

See http://camel.apache.org/bean-binding.html[Camel's Bean Binding] documentation for more details.

== Create a BPEL Component service
Once you have your WSDL interface for the BPEL service, add the component to the SwitchYard configuration (create or define the implementation and service interface).

image::switchyard/components/bpel/new_bpel_service_1.png[New BPEL service]

image::switchyard/components/bpel/new_bpel_service_2.png[New BPEL service]

Whis will create the appropiate partnerLinks definitions.

image::switchyard/components/bpel/new_bpel_service_3.png[New BPEL service]

== Create a BPEL Component service
The created BPEL component contains a single 'implementation.bpel' element that identifies the fully qualified name of the BPEL process.

[source, java]
----
<sca:component name="Process">
   <sca:implementation.bpel process="process:Process"/>
   <sca:service name="Payment">
      <sca:interface.wsdl interface="META-INF/paymentService.wsdl#wsdl.porttype(Payment)"/>
   </sca:service>
</sca:component>
----

The component may also contain one or more service elements defining the WSDL port types through which the BPEL process can be accessed.

== Create a BPEL Component service
Define your process using WS-BPEL (e.g. using the Eclipse BPEL editor bundled with JBossTools).

image::switchyard/components/bpel/new_bpel_service_4.png[New BPEL service]

== Create a BPEL Component service
Define a Deployment Descriptor (/deploy.xml) using the ODE Deployment Descriptor editor bundled with JBossTools.

image::switchyard/components/bpel/new_bpel_service_5.png[New BPEL service]

== BPEL Component consuming a service

image::switchyard/components/bpel/invoke_service_from_bpel_1.png[Invoke BPEL service]

The first step is to define the WSDL interface(s), representing the service(s) to be consumed, using an invoke element within the deployment descriptor

[source,java]
----
<process name="ls:loanApprovalProcess">
        <active>true</active>
        <process-events generate="all"/>
        <provide partnerLink="customer">
            <service name="ls:loanService" port="loanService_Port"/>
        </provide>
        <invoke partnerLink="assessor" usePeer2Peer="false">
            <service name="ra:riskAssessor" port="riskAssessor_Port"/>
        </invoke>
    </process>
----

NOTE: The 'usePeer2Peer' property informs the BPEL engine not to use internal communications for sending messages between BPEL processes that may be executing within the same engine, and instead pass messages through the SwitchYard infrastructure.

For each consumed service, we then need to create a reference element within the SwitchYard configuration, to locate the WSDL file and identify the port type associated with the required WSDL service/port.

[source,java]
----
<sca:component name="loanService">
   <bpel:implementation.bpel process="ls:loanApprovalProcess" />
   <sca:service name="loanService">
      <sca:interface.wsdl interface="loanServicePT.wsdl#wsdl.porttype(loanServicePT)"/>
   </sca:service>
   <sca:reference name="riskAssessor" >
      <sca:interface.wsdl interface="riskAssessmentPT.wsdl#wsdl.porttype(riskAssessmentPT)"/>
   </sca:reference>
</sca:component>
----

== Structure of a BPEL application

image::switchyard/components/bpel/switchyard-BPEL-structure.png[BPEL application]

NOTE: The important part is how the artifacts are structured within the src/main/resources folder.

* The switchyard.xml configuration file is located in the META-INF folder as usual. However the BPEL deployment descriptor (deploy.xml), and the BPEL process definition are located in the root folder.
* The WSDL interface definitions, and any accompanying XSD schemas, can be located in sub-folders. If they are, then the BPEL process and SwitchYard BPEL component configuration must define the correct relative path.

== BPEL Component TIPS

* Avoid usage of BPEL components if possible

== Knowledge Services

* BPM component
* Rules component

Both BPM and Rules share the same execution engine, and share some common configurations

== BPM Component
To create a new BPM service in SwitchYard, you'll need the following information:

* File Name: the file name that will be used to create a new, empty BPMN 2 Process definition.
* Interface Type: the contract for the service being provided.  BPM supports Java, WSDL, and ESB contract types.
* Service Name: the name of the service your process will provide.

image::switchyard/components/bpm/new_bpm_service_1.png["New BPM component"]

image::switchyard/components/bpm/new_bpm_service_2.png["New BPM component"]

== Process interaction
Interaction with a process is defined via actions on a BPM service component.

[source,java]
----
package org.switchyard.userguide;
public interface MyService {
    public void start(String data);
    public void signal(String data);
    public void abort(String data);
}
----

Actions allow you to map an operation in the service contract to one of the following interactions with a business process:

----
START_PROCESS
SIGNAL_EVENT
SIGNAL_EVENT_ALL
ABORT_PROCESS_INSTANCE
----

image::switchyard/components/bpm/bpm_actions.jpg["BPM actions"]

== Starting a Process Instance
Operations configured with the *START_PROCESS* action type will start new process instances.

When you start your process (actually, any interaction with a service whose implementation is bpm), the processInstanceId will be put into the Switchyard Context at *Scope.MESSAGE*, and will be fed back to your client in a binding-specific way.  For soap, it will be in the form of a soap header in the soap response envelope:

[source,xml]
----
<soap:Header>
    <bpm:processInstanceId xmlns:bpm="urn:switchyard-component-bpm:bpm:1.0">1</bpm:processInstanceId>
</soap:Header>
----
In future process interactions, you will need to send back that same processInstanceId, so that the correlation is done properly.  For soap, that means including the same soap header that was returned in the response to be sent back with subsequent requests.

NOTE: If you are using persistence, the sessionId will also be available in the Context, and will need to be fed back as well.  It would look the same way in the soap header as the processInstanceId does.

== Correlation Keys
If you do not want to track the processInstanceId, however need to have multiple interactions with the same process instance, you can start the process with your own application-specific correlation key, and include that same correlation key for future interactions.  Here is an example of including in a a soap request:

[source,xml]
----
<soap:Header>
    <bpm:correlationKey xmlns:bpm="urn:switchyard-component-bpm:bpm:1.0">MY-APP-KEY-0123456789</bpm:correlationKey>
</soap:Header>
----

== Signaling a Process Instance
Operations configured with the *SIGNAL_EVENT* operation type will have the associated process instance signaled. 

NOTE: The processInstanceId will need to have been available in the Context so the correct process instance is correlated.

There are two other pieces of information when signaling an event:

* The *"event id"*.  In BPMN2 lexicon, this is known as the "signal id", but in jBPM can also be known as the "event type".  This is set as the eventId in the configuration.

NOTE: In BPMN2, a signal looks like this: <signal id="foo" value="bar"/>  In jBPM, it is the signal id that is respected, not the name.  This might require you to tweak a tooling-generated id to whatever you want it called.

* The *"event object"*.  This is the data representing the event itself, coming from the Message content object itself (your payload).

Operations configured with the *SIGNAL_EVENT_ALL* operation type will have all process instances signaled.

== Aborting a Process Instance
Operations configured with the *ABORT_PROCESS_INSTANCE* operation type will cause associated process instances to be aborted.

NOTE: The processInstanceId will need to have been available in the Context so the correct process instance is correlated.

== BPM Operations mappings
SwitchYard provides a flexible way to map data in and out service operation invocations via MVEL expressions.

image::switchyard/components/bpm/bpm_operations.png["Operations mappings"]

The above will create XML configuration like this:

[source,xml]
----
<operation name="process" type="START_PROCESS">
  <inputs>
    <input from="message.content.policy" to="Policy"/>
    <input from="message.content.driver" to="Driver"/>
  </inputs>
  <outputs>
    <output from="Policy" to="message.content"/>
  </outputs>
  <faults>
    <fault from="ProcessingFault" to="message.content"/>
  </faults>
</operation>
----

NOTE: All of the different mapping types support a from and to attribute. Those attributes get configured with MVEL expressions, which themselves support variables that can come from process or global variable names, implicit variable names, or variables that get resolved from properties.

== Globals
If your process executes business rules, you can use global mappings to access data in your rules which do not trigger rule execution themselves, but can be used in either the LHS or RHS of your rules for customization. 

== Inputs
For the BPM component, inputs are used to set process instance variables that can later be referenced by nodes within your process.

NOTE: For you to be able to use variables inside your process, you have to declare your variable names at the process level, as well as in the Parameter Mapping (and possibly Result Mapping) of any process node that wants access to those variables. This can be done easily in the BPMN2 Eclipse tooling by using the Properties view when clicking on either the whitespace around the process, or on any of your process nodes.

== Outputs
Outputs are used to extract process instance variables so that they can be set in the outgoing SwitchYard Message content.

== Faults
Fault mapping is similar to Output mapping, however the data represents an Exception or data that will be wrapped in an Exception.

== Implicit variables

* *context*: The current org.switchyard.Context.
* *message*: The current org.switchyard.Message.

Examples:
----
from="message.content" - This is the same as message.getContent().
from="context[‘foo’]" - This is the same as context.getProperty("foo", Scope.MESSAGE).getValue(), in a null-safe manner.
----

== Calling a BPM process
We are going to do a walk through of creating a BPM process and calling it from SwitchYard. Our process will call 3 other SwitchYard service as part of it orchestration logic.

image::switchyard/components/bpm/bpm_process_definition.png["Process Definition"]

Our process consist of one method, that receives an *Order* and answers with an *OrderAck*.

[source,java]
----
import org.switchyard.quickstarts.bpm.service.data.Order;
import org.switchyard.quickstarts.bpm.service.data.OrderAck;

public interface ProcessOrder {
    OrderAck submitOrder(Order order);
}
----

To invoke the BPM process, we select the properties for the BPM component in the Switchyard editor, and map the operations to BPM process events. For this particular example, we will map the *submitOrder* operation to trigger the start of the process with *START_PROCESS*, and we map the operation input and output data types to the process data types.

image::switchyard/components/bpm/process_properties_2.png["Process operation mapping"]

As can be seen, the operation input value is mapped with *message.content* to a process variable called *input_param*. For the operation return type, we get the process result, which will come in a process variable that we have called *output_result*. (By default, BPM will use an output variable called *Result*).

Our process definition is quite simple, it will invoke a SwitchYard service, and will evaluate the result of this invocation to decide which other service to call amongst two. The result of the invocation of this last service call will be used as a result of the whole process, this means, as a result of the operation being invoked.

image:switchyard/components/bpm/process.png["Process definition"]

To be able to interact with SwitchYard, we map the input and output parameters to "Process variables", as well as we declare some other variables to be used along the process execution.

image:switchyard/components/bpm/variables.png["Process Variables definition"]

When you want to invoke from a BPM process a *SwitchYard Service*, that means a SwitchYard "Reference", you just drop the *SwitchYardServiceTask* to the canvas and set the required properties. By default there will be the required properties for the invocation:

image:switchyard/components/bpm/switchyard_task_defaults.png["SwitchYard Service Task defaults"]

We then need to fill:

* *ServiceName*
* *OperationName*

And then map the SwitchYard Task invocation parameters, to the process variables. (Shown in red in the picture below)

image:switchyard/components/bpm/switchyard_task_params.png["SwitchYard Service Task params"]

In this example, we have copied the result of the call to the Inventory service into a process variable called *InventoryAvailable* that we use in the following gateway to select where to divert.

image:switchyard/components/bpm/divert.png["Exclusive gateway"]

Once the gateway selects the route to take, it is time to call last "SwitchYard Service", and again, setting up required fields and mappings to process variables. This time, the result of the execution of the SwitchYard Service will be mapped to the BPM process output.

image:switchyard/components/bpm/process_output.png["Process output mapping"]

NOTE: The name of the process defines the scope for the process variables. (ProcessOrder in this example)

== Rules Component
To create a new Rules service in SwitchYard, you'll need the following information

* *File Name*: the file name that will be used to create a new template rules definition.
* *Interface Type*: the contract for the service being provided.  Rules services support Java, WSDL, and ESB contract types.
* *Service Name*: the name of the service your process will provide.
* *Package Name*: package name used for the new Rules file.

image::switchyard/components/rules/new_rules.jpg[New Rules component]

== Rules Component

The ExampleService interface can be as simple as this (with no SwitchYard-specific imports):

[source,java]
----
package com.example.switchyard.docs;
public interface Example {
    public void process(MyData data);
}
----

The generated rule template will look like this:
[source,java]
----
package com.example.switchyard.docs
import org.switchyard.Message
global Message message
 
rule "RulesExample"
   when
      // insert conditional here
   then
      // insert consequence here
      System.out.println("service: ExampleService, payload: " + message.getContent());
end
----

== Rules Operations mappings
SwitchYard provides a flexible way to map data in and out service operation invocations via MVEL expressions.

image::switchyard/components/rules/rules_operations.png["Operations mappings"]

The above will create XML configuration like this:

[source,xml]
----
<operation name="process" type="EXECUTE">
  <globals>
    <global from="context['org.switchyard.messageId']" to="messageId"/>
  </globals>
  <inputs>
    <input from="message.content.policy"/>
    <input from="message.content.driver"/>
    <input from="context['org.example.foobar']"/>
  </inputs>
  <outputs>
    <output from="globals.Result" to="message.content"/>
  </outputs>
  <faults>
    <fault from="globals.Fault" to="message.content"/>
  </faults>
</operation>
----

== Generated rules service

[source,java]
----
package org.switchyard.example.docs
 
global java.lang.String messageId
global java.util.Map globals
 
rule "Approval"
    when
        policy : Policy(threshold >= 600)
    then
        policy.setFlag(true);
        globals.put("Result", policy);
end
 
rule "Denial"
    when
        policy : Policy(threshold < 600)
    then
        policy.setFlag(false);
        globals.put("Result", policy);
end
----

== Globals
If your process executes business rules, you can use global mappings to access data in your rules which do not trigger rule execution themselves, but can be used in either the LHS or RHS of your rules for customization. 

They also provide a nice way to define in/out "buckets" so you can get data out of rule execution.

[source,java]
----
   globals.put("resultingPolicy", policy);
----

IMPORTANT: The global variable called globals (java.util.Map) is always available for in/out purposes.  You don't have to configure it in your <globals> section for it to be available to your BPM/DRL.

== Globals - TIP
If you want to use your own application object as in in/out variable, you are free to do so.

You can even dynamically create your own Map using *MVEL* and name it what you want.

[source,xml]
----
<operation name="process" type="EXECUTE">
  <globals>
    <!-- the from is an MVEL construct which creates a new Map -->
    <global from="['':'']" to="holder"/>
  </globals>
  <outputs>
    <!-- this assumes you did a holder.put("out", someObject) at some point -->
    <output from="holder.out" to="message.content"/>
  </outputs>
</operation>
----

== Inputs
Inputs are the "facts" that are inserted into the Drools rules engine.

NOTE: If you do not specify your own Inputs, the default will be the incoming Message content. 

IMPORTANT: If you do specify your own Inputs, the incoming Message content will not be inserted as a fact, and you will have to include "message.content" yourself, if desired.

== Outputs
Using in/out variables (for example, the global Map called "globals"), we can extract data out of the rules execution and into the outgoing Message content.

IMPORTANT: If you do not specify your own Outputs, the default will be the result of the expression "globals.Result".

WARNING: If you do not specify your own Outputs, or in your DRL, you do not populate the "Result" of the globals Map, then your Rules component execution will return null. For IN_OUT Exchange patterns this is a problem.

== Faults
Fault mapping is similar to Output mapping, however the data represents an Exception or data that will be wrapped in an Exception.

== Stateless vs. Stateful Rules Execution

*Rules services are stateless by default*. Service method invocation will create a new Drools knowledge session, execute it given the passed-in domain data, and then be cleanly disposed.

*To use a stateful session*, use the FIRE_ALL_RULES action type instead of EXECUTE.

*To insert facts into a stateful knowledge session without firing the rules*, use the INSERT operation type.

== Channels
* Drools supports the notion of "Channels", which are basically "exit points" in your DRL.
* They can be used in both stateful and stateless sessions.

[source,java]
----
package com.example
rule "example rule"
    when
        $f : Foo ( bar > 10 )
    then
        channels["Bar"].send( $f.getBar() );
end
----

[source,xml]
----
<channels>
    <channel class="com.example.BarChannel" name="Bar"/>
</channels>
----

WARNING: Channels must implement org.kie.api.runtime.Channel.

== Consume another SwitchYard Service from a rules service
SwitchYard provides an out-of-the-box Channel which allows you to invoke (one-way) other SwitchYard services directly and easily from your DRL.

[source,xml]
----
<channel name="HelloWorld" reference="HelloWorld" operation="greet"/>
----

Parameters to the SwitchYard channel
* *class*: The channel implementation class. (Default is SwitchYardServiceChannel.)
* *name*: The channel name. (default = simple name of the implementation class)
* *reference*: The service reference qualified name.
* *operation* The service reference operation name.

== Complex Event Processing - Configure
How to configure via XML? (it can be done via JBDS tooling)

[source,xml]
----
<implementation.rules ...>
    <operations>
        <operation eventId="FooStream" name="processFooMessage" type="FIRE_UNTIL_HALT"/>
        <operation eventId="BarStream" name="processBarMessage" type="FIRE_UNTIL_HALT"/>
    </operations>
    ...
    <properties>
        <property name="drools.clockType" value="realtime"/>
        <property name="drools.eventProcessingMode" value="stream"/>
        <property name="drools.maxThreads" value="1"/>
        <property name="drools.multithreadEvaluation" value="false"/>
    </properties>
</implementation.rules>
----

NOTE: The type of "FIRE_UNTIL_HALT" is required for CEP scenarios.

== Complex Event Processing - Insert facts
*How do facts (data) get inputted for CEP?*

Operations of type FIRE_UNTIL_HALT can specify <inputs> just like any other operation. If all of your inputs have "from" attributes but not "to" attributes, then:

* If the "eventId" attribute on the operation element is set, then the eventId is your entry point that the data gets inserted into. (Unicast)
* If the "eventId" attribute on the operation element is not set, then everything gets inserted into the stateful session, not into an entry point. ((Multicast)

== KnowledgeServices Listeners
Listeners are used to monitor specific types of events that occur during Knowledge execution.

[source,xml]
----
<listeners>
    <listener class="org.drools.core.event.DebugProcessEventListener"/>
    <listener class="org.kie.api.event.rule.DebugWorkingMemoryEventListener"/>
    <listener class="com.example.MyListener"/>
</listeners>
----

== KnowledgeServices Loggers
Loggers are special types of Listeners, and are used to output the events that occur during Knowledge execution. Events can be logged to the CONSOLE or to a FILE.

[source,xml]
----
<loggers>
    <logger interval="2000" log="myLog" type="THREADED_FILE"/>
    <logger type="CONSOLE/>
</loggers>
----

== KnowledgeServices MANIFEST
MANIFEST is where you specify where the "intelligence" of the component comes from. 

* For the *BPM* component, this will be, at the minimum, the location of the BPMN 2 process definition file.
* For the *Rules* component, this will most likely be the location of DRL, DSL, DSLR or XLS files. 

There are two ways to to configure the Manifest:

* With a KIE Container. This relies upon the existence of a META-INF/kmodule.xml configuration file.
* With a manually defined list of Resources.

WARNING: These two options are mutually exclusive.

.META-INF/kmodule.xml
[source,xml]
----
<kmodule xmlns="http://jboss.org/kie/6.0.0/kmodule">
    <kbase name="com.example">
        <ksession name="my-session" type="stateless"/>
    </kbase>
</kmodule>
----

.META-INF/switchyard.xml
[source,xml]
----
....
<bpm:implementation.bpm persistent="false" processId="ProcessOrder">
   <bpm:manifest>
      <!-- // This element is needed when the ksession is defined in the kmodule.xml
      <bpm:container sessionName="my-session"/> 
      -->
      <bpm:resources>
         <bpm:resource location="ProcessOrder.bpmn" type="BPMN2"/>
         <bpm:resource location="com/example/MyRules.drl" type="DRL"/>
      </bpm:resources>
   </bpm:manifest>
   ...
</bpm:implementation>
...
----

== KnowledgeServices Configuration Properties
Properties are the way to provide "hints" to the underlying KIE/Drools/jBPM runtime on how certain options are configured.

WARNING: Properties are an advanced topic, so setting them should be done with care.

NOTE: All possible property names and values will not be listed here. To view them, in your IDE open up a Type Heirarchy with a root of *org.kie.api.conf.Option*.

[source,xml]
----
<properties>
    <property name="drools.clockType" value="pseudo"/>
    <property name="drools.eventProcessingMode" value="stream"/>
</properties>
----
== Core concepts

SwitchYard uses Camel internally to communicate between its parts (bindings and components) and follows Camel concepts in terms of Messages, Exchange, ...

image::switchyard/core_switchyard.png[SwitchYard Core concepts]

== Core concepts - org.switchyard.Message

A Message represents an individual input or output of a service, the content of which is interpreted by service implementation logic.

A Message does not carry context specific to a service invocation, which means that it can be copied and reused across service invocations. There are two distinct parts to a message:

* *Content*: the main body, or payload, of the message. There is only one body per message instance. The message body is mutable, so message processing logic can access the content, change it (transform, enrich, etc.), and then set it back on the message.
* *Attachments*: provide the ability to associate content with a message separate from  the main body, allowing it to be parsed independently. One example  would be a binary image that is referenced by the main body of the message.  The attachment may be too large to be processed in certain services or the service implementation may not be able to  parse/interpret it.

== Core concepts - org.switchyard.Exchange

An Exchange provides a conduit for the messages that flow into and out of a service  as part of a service invocation.

An Exchange represents an instance of a service invocation with a specific message exchange pattern (e.g. InOnly, InOut).  

Unlike messages, an exchange cannot be copied and reused across service invocations. State associated with an invocation (i.e. context) is maintained at the exchange level.

* *org.switchyard.ExchangePhase*: Represents the phase of an exchange. (INPUT or OUTPUT)

* *org.switchyard.ExchangeState*: Represents the state of an Exchange (OK, FAULT)

* *org.switchyard.ExchangePattern*: The list of supported exchange patterns within SwitchYard. (IN_ONLY, IN_OUT)

* *org.switchyard.metadata.ExchangeContract*: Two-way Exchange contract, detailing the requirements of both the consumer and provider ServiceOperation being invoked.

== Core concepts - org.switchyard.Context

Holds contextual information around the exchange of messages between a service consumer and provider.

== Core concepts - org.switchyard.Service

A service registered with the SwitchYard runtime.

== Core concepts - org.switchyard.ServiceReference

A service registered with the SwitchYard runtime.

== Core concepts - org.switchyard.ServiceDomain

A ServiceDomain represents a collection of services with a shared set of resources, configuration, and policy definitions.  The ServiceDomain interface is used by software components to provide and/or consume services.  These software components include protocol gateways, service containers, translation engines, adapters, orchestration and routing engines.

== Core concepts - org.switchyard.metadata.ServiceOperation
epresentation of an operation on a ServiceInterface. Each operation has:

* an exchange pattern (IN_OUT, IN_ONLY)
* a name
* an input message referenced type
* an (optional) output message type
* an (optional) fault message type

The mapping of operation and message names is defined by the concrete implementation of ServiceInterface.  For example, the expected mapping of a Java interface would be Java method name to ServiceInterface operation name.

== Core concepts - org.switchyard.metadata.ServiceInterface
The canonical representation of a service interface in SwitchYard.  

Every service in SwitchYard is registered with exactly one ServiceInterface, providing information on the type, operations, and input/output messages for the service. 

The SwitchYard runtime provides concrete implementations of ServiceInterface for Java and WSDL interface types. 

There is also a default type of *ServiceInterface.DEFAULT_TYPE* which is used to represent services which do not publish a formal contract.

== Core concepts - org.switchyard.ServiceMetadata
Contains runtime details on services and service references registered in SwitchYard.

Instances of ServiceMetadata can be created and updated using the ServiceMetadataBuilder class

== Core concepts - org.switchyard.ExchangeHandler
The role of a Handler is to handle messages and fault events during the course of a service invocation.

When consuming a service, a handler can be registered during Exchange creation to handle consumer events (e.g. fault or reply message).

When providing a service, a handler is specified while registering the service to process invocations of that service.

== Core concepts- How an Exchange works

TODO: Describe how an Exchange goes from one ServiceHandler/Exchange to another ServiceHandler/ExchangeHandler, how the message is created. How to create and set new messages back in the Exchange, What is the pipeline that drives the Exchange lifecycle,...

== Core concepts - 

== Core concepts - ServiceHandlers

Every SwitchYard application has a composite service with one or multiple bindings. 

Every binding acts as an endpoint. Incoming endpoint if it is a binding on a service or outgoing endpoint if it is a binding on a reference. 

This endpoints are created, registered and started when the aplication gets deployed, and are stoped, unregistered and destroyed when the application is undeployed.

Every endpoint implements *org.switchyard.deploy.ServiceHandler*

There are inbound handlers and outbound handlers, depending if they act as server endpoints or client endpoints.

Inbound handlers:

* org.switchyard.component.camel.common.handler.InboundHandler: An handler that acts as a gateway/entrypoint for Camel Components.
* org.switchyard.component.http.InboundHandler: Hanldes HTTP requests to invoke a SwitchYard service.
* org.switchyard.component.resteasy.InboundHandler: Handles RESTEasy requests to invoke a SwitchYard service.
* org.switchyard.component.soap.InboundHandler: Handles SOAP requests to invoke a SwitchYard service.
* org.switchyard.component.sca.SCAEndpoint: For publishing services as SCA

Outbound handlers:

* org.switchyard.component.camel.common.handler.OutboundHandler: A handler that is capable of calling Apache Camel components.
* org.switchyard.component.http.OutboundHandler: Handles invoking external HTTP services.
* org.switchyard.component.resteasy.OutboundHandler: Handles invoking external RESTEasy services.
* org.switchyard.component.soap.OutboundHandler: Handles invoking external Webservice endpoints.
* org.switchyard.component.sca.SCAInvoker: Handles outbound communication to an SCA service endpoint

image::switchyard/service_handlers.jpg[Service Handlers]

== How does an InboundHandler Works

When it is created, an instance of the BindingModel (configuration) is passed, as well as an instance of the ServiceDomain, is passed to the InboundHandler.

When it starts creates the ServiceReference representing the endpoint, the endpoint for the corresponding binding and the message composer.

Provides one method, *invoke*, where all the logic for an invocation to the endpoint happens.

When it stops, the endpoint is stopped.

== InboundHandler.invoke()

* creates an Exchange
* add identy to the Exchange to identify the origin of the invocation
* compose the message (*MessageComposer.compose()*) from the passed binding Message (*BindingData*)
* send the Message to the Exchange (*Exchange.send()*)
* If it is IN_OUT:
** it will wait for a response (Default timeout of 5 minutes)
** it will decompose the response (*MessageComposer.decompose()*)
* it returns the decomposed message as *BindingData*

== How does a message translation works
Here we will find a description of what is happening at the message composition time in a call to a SwitchYard application through an external binding and having one call to an external reference through a binding.

image::switchyard/core/MessageComposition_Flow.jpg[Message composition flow]

. *Request message from binding to service (Request from client)*. The request message is converted from the binding message type to the internal SwitchYard *Message*, and all the binding headers (HTTP, SOAP, ...) will be mapped into the corresponding properties in the SwitchYard *Context* associated to the Message, and it is set to the Exchange.
. *Service component implementations execution*. The request pipelines of a component will be executed, until a there is a call to an external service.
. *Request message from reference to binding (External service call)*. A call to the external service is about to happen, and message needs to be converted from SwitchYard Message to the reference binding data, the MessageComposer will decompose the message back to the binding format and properties will be extracted from the SwitchYard *Context* and set into the binding message. 
. *Response message from binding to reference (Response from remote service)*. Once the external service has been executed, the response from this external service will be mapped back into SwitchYard by the MessageComposer.mapFrom(). The ContextMapper will copy the appropiate message/transport headers back into the Message *Context* 
. *Service execution*. The rest of the components` pipeline will be executed.
. *Response message from service to binding (Response to client caller)*. When our application has ended it's execution and it is returning the result to the caller, the MessageComposer will decompose the SwitchYard message back to the binding message and the ContextMapper will map the properties in the Context back to the binding message.

NOTE: Additional behaviour relative to the correspoding transaltions will exist in the predefined MessageComposers and ContextMappers (SOAP, REST, HTTP,...) 

== How does an OutboundHandler Works

TODO: Define this.

== Core concepts - ExchangeHandler Chains
Communications between components and bindings to/from components is done by a LocalExchangeBus.

NOTE: This is the wire

There is a chain of ExchangeHandlers acting as interceptors for the request and response pipelines of the wire. The default chain has the following:

* *RequestChain*
** *addressing*: AddressingHandler resolves service instances based on a service reference.
** *transaction-pre-invoke*: TransactionHandler interprets transactional policy specified on an exchange and handles transactional requirements. Suspends current transaction and creates a new one, creates a new one, join an ongoing transaction,...
** *security-process*:  SecurityHandler interprets security policy specified on an exchange and handles security requirements. Cretes the SecurityContext and SecurityProvider and attaches to the thread.
** *generic-policy*: PolicyHandler
** *validation-before-transform*: ValidateHandler executes the *org.switchyard.validate.Validator* defined for the Exchange`s content type.
** *transformation*: TransformHandler applies all the defined transformations (*org.switchyard.transform.TRansformer*) for the message for consumer.inputType to provider.inputType and set the Exchange's new content type.
** *validation-after-transform*: ValidateHandler executes the *org.switchyard.validate.Validator* defined for the new Exchange`s content type.
** *provider*: ProviderHandler dispatches the message to the provider (component).
** *security-cleanup*: SecurityHandler cleanup of context and thread info.
** *transaction-post-invoke*: TransactionHandler commits or rollback, or resume suspended transaction,...

image::switchyard/core/HandlerChain_IN_ONLY.png[IN_ONLY Handler Chain]

NOTE: Only IN_OUT Exchanges will execute the ReplyChain, that's why there are 2 Handlers after the execution of the provider, to cleanup/finish tasks.
        
* *ReplyChain*
** *validation-before-transform*: ValidateHandler executes the *org.switchyard.validate.Validator* defined for the Exchange`s content type.
** *transformation*: TransformHandler applies all the defined transformations (*org.switchyard.transform.TRansformer*) for the message for provider.outputType to consumer.outputType and set the Exchange's new content type.
** *validation-after-transform*: ValidateHandler executes the *org.switchyard.validate.Validator* defined for the new Exchange`s content type.
** *HandlerChain.CONSUMER_HANDLER*: BaseHandler 

image::switchyard/core/HandlerChain_IN_OUT.png[IN_OUT Handler Chain]

== Binding/Gateways
 ** Http based
 ***  SOAP
 ***  RESTEasy
 ***  HTTP
 ** Camel based
 *** JPA
 *** JCA
 *** JMS
 *** SQL
 *** File
 *** FTP FTPS SFTP
 *** TCP UDP
 *** Quartz
 *** Timer
 *** SEDA
 ** SCA
 ** Camel URI*
 ** MessageComposers/MessageContext
 ** Operation selection
 ** Throttling

== SOAP Binding
The SOAP component in SwitchYard provides SOAP-based web service binding support for services and references. 

In FSW it is based in *JBossWS-CXF*.

== SOAP Service Binding - Details
Basic configureation

image::switchyard/bindings/soap/binding_service_soap_1.png[Soap Service binding]

* *wsdl*: location of the WSDL used to describe the web service endpoint.
* *wsdlPort*: port name in the WSDL to use.  If unspecified, the first port definition in the WSDL is used for the service endpoint
* *socketAddr*: the IP Socket Address to be used. The value can be in the form hostName/ipAddress:portNumber or hostName/ipAddress or :portNumber.
* *contextPath*: additional context path for the SOAP endpoint. (Default is none)

* *unwrapped Payload*: Checking this option it will unwrap the message's payload (explained later).
* *SOAP Headers Type*: How it will extract the SOAP headers into SwitchYard (explained later)
* *Endpoint Configuration*: cxf.xml configuration file for external endpoint configuration (Does not work)
* *MTOM*: Enable Message Transmission Optimization Mechanism for attachments

== SOAP Service Binding - Interceptors
Configure CXF interceptors for Inbound and Outbound pipelines

image::switchyard/bindings/soap/binding_service_soap_2.png[Soap Service binding]

== SOAP Service Binding - Message Composer
Configure message composition for SOAP messages. (Exlained later)

image::switchyard/bindings/soap/binding_service_soap_3.png[Soap Service binding]

== SOAP Service Binding Example
[source,xml]
----
<sca:composite name="orders" targetNamespace="urn:switchyard-quickstart-demo:orders:0.1.0">
   <sca:service name="OrderService" promote="OrderService">
      <soap:binding.soap name="soap1">
         <soap:contextMapper includes="custom.*" soapHeadersType="XML"/>
         <soap:messageComposer unwrapped="true"/>
         <soap:wsdl>META-INF/orderService.wsdl</soap:wsdl>
         <soap:wsdlPort>OrderPort</soap:wsdlPort>
         <soap:socketAddr>:9091</soap:socketAddr>
         <soap:contextPath>order-test</soap:contextPath>
         <soap:endpointConfig configFile="SecureEndpointConfig.xml" 
                              configName="SecureOrder"/>
         <soap:mtom threshold="1500" xopExpand="true"/>
         <soap:inInterceptors>
            <soap:interceptor class="org.apache.cxf.interceptor.LoggingInInterceptor"/>
         </soap:inInterceptors>
         <soap:outInterceptors>
            <soap:interceptor class="org.apache.cxf.interceptor.LoggingOutInterceptor"/>
         </soap:outInterceptors>
      </soap:binding.soap>
   </sca:service>
</sca:composite>
----

== SOAP Service Binding - Unwrapped payload
It will remove the wrapper part of the message, which usually translates to the operation for you.

[source,xml]
----
<soap:Body>  
   <orders:submitOrder xmlns:orders="urn:switchyard-quickstart:bean-service:1.0">  
      <order>  
         <orderId>PO-19838-XYZ</orderId>  
         <itemId>BUTTER</itemId>  
         <quantity>200</quantity>  
      </order>  
   </orders:submitOrder>  
</soap:Body>  
----

The message you will be passed will be:
[source,xml]
----
<order xmlns:orders="urn:switchyard-quickstart:bean-service:1.0">  
   <orderId>PO-19838-XYZ</orderId>  
   <itemId>BUTTER</itemId>  
   <quantity>200</quantity>  
</order>
----

NOTE: if (unwrapped){ ...// peel off the operation wrapper, if present ...}

IMPORTANT: It will unwrap the request and wrap back the response (if not already wrapped).
  
See: 

* org.switchyard.component.soap.composer.SOAPMessageComposer.compose(...)
* org.switchyard.component.soap.composer.SOAPMessageComposer.decompose(...)

== SOAP Headers type

Header sent:

[source,xml]
----
<typ:amount xmlns:typ="http://ws.camelcookbook.org/payment-service/types">1000</typ:amount>
----

* *CONFIG*: *org.switchyard.config.Configuration* object based on the SOAP header
* *DOM*: XML representation of the element, in DOM format. 
* *Value*: Value of the element (1000)
* *XML*: String representation of the SOAP header XML element.

See: *org.switchyard.component.soap.composer.SOAPContextMapper.mapFrom(...)*

== SOAP Service Binding CAVEATS

* The url where the service is published can only be known at deploy time from the logs.
* The url is composed in the form of http://<host>:<port>/<artifactName>/<context>/<xxxx>
* In AS7 by default the JBossWS-CXF stack is enabled and hence the socketAddr parameter will be ignored. This parameter can be used for standalone usage (Unit tests).

== SOAP Reference Service Binding
Binding a reference with SOAP can be used to make SOAP-based web services available to SwitchYard services.

image::switchyard/bindings/soap/binding_reference_soap_1.png[Soap reference binding]

== SOAP Reference Binding

image::switchyard/bindings/soap/binding_reference_soap_2.png[Soap reference binding]

== SOAP Reference Binding

image::switchyard/bindings/soap/binding_reference_soap_3.png[Soap reference binding]

== SOAP Reference Binding

image::switchyard/bindings/soap/binding_reference_soap_4.png[Soap reference binding]

== SOAP Binding Capabilities

* *WS-Security*
** *UsernameToken Support*
** *Signature and Encryption Support*
* *Attachments* (y default any attachment sent with a SOAP Envelope is passed around in a SwitchYard Message as an attachment. The default SOAPMessageComposer handles this.)
** *SOAP with Attachments (SwA)*
** *SOAP with MTOM/XOP*:
* *WS-Addressing*

See: https://docs.jboss.org/author/display/SWITCHYARD/SOAP

== Switchyard - RESTEasy Binding

 TODO: Create this

== Switchyard - HTTP Binding

 TODO: Create this

== Switchyard - JPA Binding

 TODO: Create this

== Switchyard - JCA Binding

 TODO: Create this

== Switchyard - JMS Binding

 TODO: Create this

- Where does #ConnectionFactory come from???
https://community.jboss.org/thread/243227
- use custom jndiPropertiesFile
- Use a .ra
- Configuration for tests with hornetq-jms.xml, hornetq-ra.xml, ...

== Switchyard - SQL Binding

 TODO: Create this

== Switchyard - File Binding

 TODO: Create this

== Switchyard - FTP FTPS SFTP Binding

 TODO: Create this

== Switchyard - TCP UDP Binding

 TODO: Create this

== Switchyard - Quartz Binding

 TODO: Create this

== Switchyard - Timer Binding

 TODO: Create this

== Switchyard - SEDA Binding

 TODO: Create this

== Switchyard - SCA Binding

 TODO: Create this

== Switchyard - Camel URI Binding

 TODO: Create this

==  Composers
A MessageComposer can compose or decompose a native binding message to/from SwitchYard's canonical message.  A MessageComposer does this in three steps:

1. Construct a new target message instance.
2. Copy the content ("body") of the message.
3. Delegate the header/property mapping to a ContextMapper.

 We currently provide a SOAPMessageComposer, a HttpMessageComposer, and a RESTEasyMessageComposer, CamelMessageComposer.  These default implementations are used by their associated bindings, but can be overridden by the user.

[source,java]
----
public interface MessageComposer<D extends BindingData> {
    public ContextMapper<D> getContextMapper();
    public MessageComposer<D> setContextMapper(ContextMapper<D> contextMapper);

    public Message compose(D source, Exchange exchange) throws Exception;
    public D decompose(Exchange exchange, D target) throws Exception;
}
----

== SOAPMessageComposer - compose

NOTE: compose happens in requests to Services and responses from References 

. creates a SwitchYardMessage
. call the SOAPContextMapper.mapFrom to copy all the headers into the context
. if it is a SOAPFault, creates a Message with the contents being the SOAPFaultDetail and returns it (This is for responses from References)
. otherwise creates a Message with the SOAPEnvelope contents (unwrapped if configured) and adds all the SOAP attachments to the SwitchYard Message attachments

WARNING: This is a rough simplification, as there are many validations and more logic inside

== SOAPMessageComposer - decompose

NOTE: decompose happens in responses from Services and requests to References 

. if the message is already a SOAP Message, just return it
. otherwise creates a SOAP message from the contents of the SwitchYard message (wrap the message if configured and needed), and return a SOAPFault if message is a fault
. add the existing attachments in the SwitchYard Message
. if message is an Exception, throw the Exception and let JAX-WS format the fault
. call the SOAPContextMapper.mapFrom to copy all the headers into the context
. returns the binding data (SOAP Message)

WARNING: This is a rough simplification, as there are many validations and more logic inside

== HttpMessageComposer

TODO: Document

== RESTEasyMessageComposer

TODO: Document

== CamelMessageComposer

TODO: Document


== Context Mappers
A ContextMapper moves native binding message headers and/or properties to/from SwitchYard's canonical context.  

 Many ContextMapper implementations are provided OOTB. These default implementations are used by their associated bindings, but can be overridden by the user.
[source,java]
----
public interface ContextMapper<D extends BindingData> {
    public ContextMapperModel getModel();
    public void setModel(ContextMapperModel model);

    public void mapFrom(D source, Context context) throws Exception;
    public void mapTo(Context context, D target) throws Exception;
}
----

== SOAPContextMapper - mapFrom

NOTE: mapFrom happens in requests to Services and responses from References 

. if message has a fault, set it as a property in the context with key "soap_fault_info" and label "SOAP_HEADER_LABELS"
. if there is HTTP status code, set it as property with key "http_response_status" and label "SOAP_MIME_LABELS"
. get all the mime headers and set them as properties with the header name as key and label "SOAP_MIME_LABELS"
. get all the soap headers and set them as properties with the header *QName* as key and label "SOAP_HEADERS_LABELS", transformed according to the binding configuration (config, value, dom, xml)

WARNING: This is a rough simplification, as there are many validations and more logic inside

== SOAPContextMapper - mapTo

NOTE: mapTo happens in requests to Services and responses from References 

. iterate over all the context properties
. if it qualiefies as a SOAP header (that means the property name is a *QName*) and matches the filtered headers configured in the binding (for the whole QNAME) add convert to SOAP header and add to returned message
. otherwise, if it matches the configured header filter or it is a property with an label of *EnpointLabel.HTTP* it will be added as mime_header with the property as header name, and the property value as header value
. (special case) if the property name is *SOAPContextMapper.HTTP_RESPONSE_STATUS* the the value (integer) will be set as status for the SOAP message.

WARNING: This is a rough simplification, as there are many validations and more logic inside


== HTTPContextMapper

TODO: Document

== RESTEasyContextMapper

TODO: Document

== CamelContextMapper

TODO: Document

== Message Composition Explained with an example

Here we will find a description of what is happening at the message composition time in a call to a SwitchYard application through an HTTP binding and having one call to an external reference through an HTTP binding.

image::switchyard/core/MessageComposition_Flow.jpg[Message composition flow]

== (1) Request message from binding to service
The request message is converted from the binding message type to the internal service type. For this to happen, a call to *HttpMessageComposer.compose()*.

In this method two things will happen:

* It will create a *Message* for the *Exchange*.

* A call to *HttpContextMapper.mapFrom(HttpRequestBindingData, context)* will be done. This method will:

** It will copy *requestInfo* from the *HTTPRequestBindingData* into the message *Context* with key *HttpComposition.HTTP_REQUEST_INFO* and assigning the following labels, *ComponentLabel.HTTP* and *EndpointLabel.HTTP*

NOTE: HttpRequestInfo has all the required information from the request, and is the source of information that can be used in the SwitchYard's component implementations to access information relative to the request, such as requestURI, requestPath, method, contextPath,... link:https://github.com/jboss-switchyard/components/blob/master/http/src/main/java/org/switchyard/component/http/composer/HttpRequestInfo.java#L35-L56[See the implementation of this class to find all the available information].

** It will copy all headers from the HTTP request that match the defined includes and exludes regex pattern for the composer at design time.

NOTE: Headers are not automatically copied, you have to add to messageComposer which headers you want to include (.*: all)

image::switchyard/core/MessageComposer_Configuration.png[Message Composer Configuration]

WARNING: When checking for headers, or defining headers in Binding's RegEx Inclusion and Exclusion, all headers are *lowercased*. If you send a header *Authorization*, you should check for *authorization* instead.

* It will copy the content from the *HttpBindingData* to the *Message* that will flow through SwitchYard converting it to the appropiate type.

* It will return the *Message*.

== (2) Service component implementations execution
The request pipelines of a component will be executed, until a there is a call to an external HTTP service.

== (3) Request message from reference to binding
A call to the external service is about to happen, and message needs to be converted from SwitchYard message to the reference binding data.

* A call to *HttpMessageComposer.decompose(Exchange, HttpRequestBindingData)* will be done. This method will:
** Copies the content from the *Exchange* to the content *HttpRequestBindingData*
** Calls *HttpContextMapper.mapTo(Request)* to copy headers from the Message`s *Context* to the HttpRequestBindingData's http headers. These properties will be copied only if they match the registered regexp expressions in the MessageComposer's design time configuration or if the properties are marked with the EndpointLabel.HTTP label in the Context.


== (4) Response message from binding to reference
Once the external service has being executed, we have to deal with the response from this external service, and map it back into SwitchYard. To to this, a call to *HttpMessageComposer.compose(HttpResponseBindingData, Exchange) will be done. This method will:

* Create a Message

* Call *HttpContextMapper.mapFrom(HttpResponseBindingData, Message)* that will:
** Copies the statusCode of the invocation into a Context property called *HttpContextMapper.HTTP_RESPONSE_STATUS* with labels http (ComponentLabel.HTTP and EnpointLabel.HTTP)
** It will copy all headers from the HTTP response that match the defined includes and exludes regex pattern for the composer at design time.

NOTE: Headers are not automatically copied, you have to add to messageComposer which headers you want to include (.*: all)

* It will copy the content from the *HttpBindingData* to the *Message* that will flow through SwitchYard converting it to the appropiate type.

* It will return the *Message*.

== (5) Service execution
The rest of the components` pipeline will be executed.

== (6) Response message from service to binding
When our application has ended it's execution and it is returning the result to the caller, it will call again *HttpMessageComposer.decompose(Exchange, HttpResponseBindingData)* to convert the SwitchYard message to the binding message or content.
It will:
* Get statusCode from Context property *HttpContextMapper.HTTP_RESPONSE_STATUS* that has been established as part of the SwitchYard service execution.

NOTE: This property could be the one that was set from the invocation to the external Composite's Reference. (In step 4)

- If there is no statusCode set as a property, or this statusCode property does not have the *EndpointLabel.HTTP*  label, it will calculate one depending on the content and on the *Exchange.getState*. If the state of the Exchange is *ExchangeState.FAULT* it will return an HTTP Error code of *500*. (link:https://github.com/jboss-switchyard/components/blob/master/http/src/main/java/org/switchyard/component/http/composer/HttpMessageComposer.java#L73-L88[See the code for the logic determining the statusCode])
* Copy the content from the SwitchYard's *Message* to the *HttpResponseBindingData*
* Call HttpContextMapper.mapTo(HttpResponseBindingData) that will:
** Copy headers from the Message`s *Context* to the HttpRequestBindingData's http headers. These properties will be copied only if they match the registered regexp expressions in the MessageComposer's design time configuration or if the properties are marked with the EndpointLabel.HTTP label in the Context.
** If the property is *HttpContextMapper.HTTP_RESPONSE_STATUS* it will set the status on the HttpResponseBindingData


== HOWTO pass a header from an incoming request to use it in the SwitchYard application
You need to add the header in the Message Composer design time configuration screen for the Composite Service Http Binding.

image::switchyard/core/pass_header.png[Authorization header]

NOTE: Remember that headers are *lowercased*.

If you want to progress this header to a Composite Reference, you need to add it again to the Composite Reference Http Binding's Message Composer design time configuration screen

== HOWTO send a header to an outgoing request
You need to add the header in the context of the invocation with EndpointLabel.HTTP. To be able to modify aspects of the call to the reference, this need to be done as a ReferenceInvoker rather than as a regular Reference.

[source,java]
----
@Inject
@Reference("RealHttpService")
private ReferenceInvoker referenceInvoker;

public String myBeanMethod(String params){
   String replyContent = "";
   ReferenceInvocation invocation = null;

   try{
      invocation = referenceInvoker.newInvocation();
      Context context = invocation.getMessage().getContext();

      // Set the header we want
      context.setProperty("Authorization", "xxxx").addLabels(EndpointLabel.HTTP.label());

      // Call the service
      replyContent = invocation.invoke(params).getMessage().getContent(String.class);
   }catch(Exception e){
      // Manage exception
   }
   return replyContent;
}
----

== HOWTO change configuration for calling service (method, queryString, queryArgs). How to invoke dynamically

WARNING: This is not possible with HTTP Binding reference. You have to use Camel binding reference.

image::switchyard/core/camel_reference_binding.png[Camel Reference binding]

To be able to modify aspects of the call to the reference, this need to be done as a ReferenceInvoker rather than as a regular Reference.

[source,java]
----
@Inject
@Reference("RealHttpService")
private ReferenceInvoker referenceInvoker;

public String myBeanMethod(String params){
   String replyContent = "";
   ReferenceInvocation invocation = null;

   // We get information from incoming request
   HttpRequestInfo requestInfo = msgContext.getPropertyValue(HttpComposition.HTTP_REQUEST_INFO);

   try{
      invocation = referenceInvoker.newInvocation();
      Context context = invocation.getMessage().getContext();

      // We copy (progress)  method, path and query string
      context.setProperty(org.apache.camel.Exchange.HTTP_METHOD, 
                              requestInfo.getMethod());
      context.setProperty(org.apache.camel.Exchange.HTTP_URI, 
                              "http://localhost:8080" +  requestInfo.getPathInfo());
      context.setProperty(org.apache.camel.Exchange.HTTP_QUERY, 
                              requestInfo.getQueryString());

      // Call the service
      replyContent = invocation.invoke(params).getMessage().getContent(String.class);
   }catch(Exception e){
      // Manage exception
   }
   return replyContent;
}
----

== HOWTO check the status code of an invocation to an external service
You need to check for the following context Property *HttpContextMapper.HTTP_RESPONSE_STATUS*

----
@Inject
@Reference("RealHttpService")
private ReferenceInvoker referenceInvoker;

public String myBeanMethod(String params){
   String replyContent = "";
   ReferenceInvocation invocation = null;

   try{
      invocation = referenceInvoker.newInvocation();
      ....
      // Call the service
      replyContent = invocation.invoke(params).getMessage().getContent(String.class);
   }catch(Exception e){
      int statusCode = invocation
                         .getContext()
                         .getPropertyValue(HttpContextMapper.HTTP_RESPONSE_STATUS);
      // Manage exception
      ...
   }
   return replyContent;
}
----

== HOWTO set the status code of an invocation to a SwitchYard application
You need to set the following context Property *HttpContextMapper.HTTP_RESPONSE_STATUS* with label *EndpointLabel.HTTP*. In order to do this in a component, you need to create a new Message and send it to the Exchange.

In a BeanComponent:

[source,java]
----
private void replyWithHTTPStatusCode(Exchange currentExchange, int statusCode) {
   Message reply = currentExchange.createMessage();
   reply.getContext().setProperty(HttpContextMapper.HTTP_RESPONSE_STATUS, 
                                  statusCode)
                     .addLabels(EndpointLabel.HTTP.label());
   currentExchange.send(reply);
}
----

In a CamelComponent:

In a Route:

[source,java]
----
.to("EXTERNAL_SERVICE")
.setHeader(HttpContextMapper.HTTP_RESPONSE_STATUS, constant(200))
----

In a Processor:

[source,java]
----
exchange.getIn().setHeader(HttpContextMapper.HTTP_RESPONSE_STATUS, statusCode);
----

== HOWTO copy all HTTP incoming headers and progress them
Right now there is no way to copy all headers from Http service binding to an Http Reference Binding but to specify all the headers you want to copy in the regex includes field for both MessageComposers.
Another option is to create your own MessageComposer, that extends the basic HttpMessageComposer and copy all the headers in the context in the Service Binding, and then set them back in the Reference Binding.

== Context Properties

*org.switchyard.Property*: Represents a context property consisting of a name, scope, and value and a set of labels.


== Scopes
Two scopes exist when defining and setting properties into the *org.switchyard.Context*:

* *Scope.EXCHANGE*: Properties available for the duration of an exchange.
* *Scope.MESSAGE*: Properties available as part of a message.

NOTE: *Headers are scoped as MESSAGE*. You will see some headers specifically useful for http requests, and other headers specifically useful for http responses. 
In both cases, they are most likely tied to the binding's notion of an incoming message or an outgoing message.

NOTE:  *Properties are scoped as EXCHANGE*, as this is most likely application or domain data, and possibly useful in the entire processing of the Exchange.

== Labels
Labels are a way to mark a Context Property, and relate it to a SwitchYard funcionality.

Base class is *org.switchyard.label.Label*

There are 5 types of labels (OOTB):

* *BehaviorLabel*: Marks the property relative to certain actions and/or behavior. (Copy of context,...) (label type: *behavior*)
** _TRANSIENT_: the property will not be preserved in a copy of the Exchange via Context.copy()
* *ComponentLabel*: Marks the property relative to certain component (label type: *component*)
** CAMEL, HORNETQ, HTTP, JCA, RESTEASY, SOAP
* *EnpointLabel*: Marks the property relative to Endpoint related actions (context composition, message composers,...) (label type: *endpoint*)
** AMQP, ATOM, DIRECT, FILE, FTP, FTPS, HTTP, JCA, JMS, JPA, MAIL, MOCK, QUARTZ, REST, SEDA, SFTP, SOAP, SQL, TCP, TIMER, UDP, URI
* *HttpInvokerLabel*: Marks the property to be used as a header in the HTTPInvoker (label type: *httpinvoker*) 
** HEADER
* *PropertyLabel*: Marks the type of the property (label type: *property*)
** HEADER, PROPERTY

== Labels (for humans)
A label is composed following this rule:

----
prefix.<lowercase(label_type)>.<lowercase(label_name)> 
----

* prefix: "org.switchyard.label."
* label type: (behavior, component, endpoint, httpinvoker, property)
* label name: (TRANSIENT, CAMEL, HTTP, JCA,....., HEADER, PROPERTY)

Examples:
----
org.switchyard.label.Label.behavior.transient
org.switchyard.label.Label.endpoint.http
org.switchyard.label.Label.endpoint.soap
org.switchyard.label.Label.component.soap
org.switchyard.label.Label.property.header
----

== Switchyard - Custom Context Mappers

 TODO: Create this


== Switchyard - Operation selection

 TODO: Create this

== Switchyard - Throttling

 TODO: Create this

== SwitchYard - Transformations (Java, JAXB, JSON, Smooks, XSLT, ...)

When is a transformation required:

 When origin type and destination type of a "wire connection" is not of the same type, and implicit type conversion (provided by Camel type converters) can not convert between both types.

 Declarative transformation only kicks in when the runtime detects that the message type is different between the consumer and provider contracts.

The tooling reflects this as well, which is why if there are no interactions where contract types differ, then you cannot create a transformer. There are three scenarios in SY where the contract types can differ and require a transformation:
 
1. A composite service interface is different from the component service interface it promotes.
2. A component reference interface is different from the component service interface it is wired to.
3. A composite reference interface is different from the component reference interface it promotes.

* Different implementations for transformations:
** Java
** JAXB
** JSON
** Smooks
** XSLT
** Transformations in a Camel component
** Other (coming next: Dozer,...)

TODO: http://www.mastertheboss.com/jboss-soa/switchyard-tutorial/page-2

== SwitchYard - Transformations - Content Type Names

Since transformations occur between named types (i.e. from type A, to type B), it's important to understand how the type names are derived. The type of the message is determined based on the service contract, which can be WSDL or Java.

For WSDL interfaces, the message name is determined based on the fully-qualified element name of a WSDL message.  Take the following WSDL definition:

[source,xml]
----
<definitions xmlns:tns="urn:switchyard-quickstart:bean-service:1.0">  
  <message name="submitOrder">
    <part name="parameters" element="tns:submitOrder"/>
  </message>
  <portType name="OrderService">
    <operation name="submitOrder">
      <input message="tns:submitOrder"/>
    </operation>
  </portType>
</definitions>
----

This would yield the following message type name based on the message element name defined in the WSDL:

[source,java]
----
{urn:switchyard-quickstart:bean-service:1.0}submitOrder
----

When Java interfaces are used for the service contract, the message name consists of the full package name + the class name, prefixed with "java:".

[source,java]
----
package org.switchyard.example;
public interface OrderService {
    void submitOrder(Order order);
}
----

The message type name for the submitOrder method in this Java interface would be *"java:org.switchyard.example.Order"*.  

Occasionally, it can be useful to override the default operation name generated for a Java interface. The *@OperationTypes* annotation provides this capability by allowing the user to specify the input, output, and/or fault type names used for a Java service interface. 

For example, if we wanted to accept XML input content without any need for transformation to a Java object model, the OrderService interface could be changed to look like this:

[source,java]
----
package org.switchyard.example;
public interface OrderService {
    @OperationTypes(in = "{urn:switchyard-quickstart:bean-service:1.0}submitOrder")
    void submitOrder(String orderXML);
}
----

Aside from short-circuiting the requirement for transformation, this annotation can be useful if you want to maintain tight control over the names used for message content.

== SwitchYard - Transformations

Required transformations are automatically detected by IDE, but, if missing, can be created/deleted/recreated manually:

image::switchyard/transformers/no_missing_transformer.png[All required validators have been added]

If you remove all/any of the transformers, you will be able to create missing required transformers:

image::switchyard/transformers/required_transformers.png[Create required transformer]

A new dialog will let you create a new transformer:

image::switchyard/transformers/new_transformer_all.png[New Transformer]

== SwitchYard - Transformations - Java
Java transformer let you do any kind of transformation using Java for this purpose. There are two methods available for creating a Java-based transformer in SwitchYard:

1. Implement the *org.switchyard.transform.Transfomer* interface and add a *<transform.java>* definition to your switchyard.xml.
2. Annotate one or more methods on your Java class with *@Transformer*.

 When using the @Transformer annotation, the SwitchYard maven plugin will automatically generate the <transform.java> definition(s) for you and add them to the switchyard.xml packaged in your application.

Implementing Java transformations is just a matter of creating a new (Java) Transformer on the SwitchYard application:

image::switchyard/transformers/new_transformer.png[New validator]

And selecting Java as the type of transformer you want implementing class or bean.

image::switchyard/transformers/new_java_transformer.png[Create a Java transformer]

It will create the appropiate transformer class/bean with the default annotated methods:

image::switchyard/transformers/java_transformer.png[Java Transformer class]

 The optional from and to elements of the @Transformer annotation can be used to specify the qualified type name used during transformer registration.  If not supplied, the full class name of the method parameter will be used as the from type and the full class name of the return type will be used as the to type.

And the corresponding configuration in the switchyard.xml file:

image::switchyard/transformers/transformer_switchyard_xml.png[Transformers defined in switchyard.xml file]

 The CDI bean name specified by @Named annotation is used to resolve transformer class. If you don't specify, then class name of the transformer is used instead.

== SwitchYard - Transformations - JAXB

The JAXB transformer allows you to perform Java to XML (and XML to Java) transformations using JAXB (XML marshalling and unmarshalling).

 JAXB Java models can be generated from an XML Schema using XJC, or from a WSDL using tools like wsconsume, or from within JBDS IDE with "JAXB`s JAXB classes from Schema" or "SwitchYard`s Java Files from WSDL".

JAXB Transformer requires a *to* and *from* with one Java type and one QNamed XML type, depending on whether you're performing a Java to XML or XML to Java transformation.

[source,java]
----
@XmlElementDecl(namespace = "http://com.acme/orders", name = "create")
public JAXBElement<CreateOrder> createOrder(CreateOrder value) {
    return new JAXBElement<Order>(_CreateOrder_QNAME, CreateOrder.class, null, value);
}
----

And the corresponding configuration in the switchyard.xml file:

image::switchyard/transformers/jaxb_transformer_switchyard_xml.png[JAXB transformers defined in switchyard.xml file]


== SwitchYard - Transformations - JSON

The JSON transformer provides a basic mapping facility between POJOs and JSON (JSON marshalling and unmarshalling). The JSON specification of the transformer requires a to and from specification with one Java type and one QNamed JSON type, depending on whether you're performing a Java to JSON or JSON to Java transformation.

[source,java]
----
<transforms>
   <xform:transform.json from="java:org.switchyard.quickstarts.transform.json.OrderAck" 
                         to="{urn:switchyard-quickstart:transform-json:1.0}orderResponse"/>
   <xform:transform.json from="{urn:switchyard-quickstart:transform-json:1.0}order" 
                         to="java:org.switchyard.quickstarts.transform.json.Order"/>
</transforms>
----

== SwitchYard - Transformations - Smooks

There are three distinct transformation models available with Smooks in SwitchYard:

1. XML to Java :  Based on a standard Smooks Java Binding configuration.
2. Java to XML:   Based on a standard Smooks Java Binding configuration.
3. Smooks :  This is a "normal" Smooks transformation in which the developer must define which Smooks filtering Result is to be exported back to the SwitchYard Message as the transformation result.

Smooks transformations are declared by including a <transform.smooks> definition in switchyard.xml.

[source,xml]
----
<transform.smooks config="/smooks/OrderAck_XML.xml"
                  from="java:org.switchyard.quickstarts.transform.smooks.OrderAck"
                  to="{urn:switchyard-quickstart:transform-smooks:1.0}submitOrderResponse"
                  type="JAVA2XML"/>
----
The config attribute points to a Smooks resource containing the mapping definition.  The type attribute can be one of SMOOKS, XML2JAVA, or JAVA2XML.

== SwitchYard - Transformations - XSLT

The XSLT transformer allows you to perform a transformation between 2 XML types, using an XSLT. It is configured simply by specifying the to and from QNames, as well as the path to the XSLT to be applied.

[source,xml]
----
<transforms>
   <transform.xslt xmlns="urn:switchyard-config:transform:1.0" 
                   from="{urn:switchyard-quickstart:transform-xslt:1.0}order" 
                   to="{urn:switchyard-quickstart:transform-xslt:1.0}orderAck" 
                   xsltFile="xslt/order.xslt"/>
</transforms>
----

And an xslt file is requierd for transformation:
[source,xml]
----
<?xml version="1.0"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	version="1.0">
	<xsl:template match="/">
		<orders:orderAck xmlns:orders="urn:switchyard-quickstart:transform-xslt:1.0">
			<xsl:for-each select="orders:order">
				<orderId>
					<xsl:value-of select="orderId" />
				</orderId>
				<accepted>
					<xsl:choose>
						<xsl:when test="(itemId = 'BUTTER') and (quantity &lt;= 200)">
							true
						</xsl:when>
						<xsl:otherwise>
							false
						</xsl:otherwise>
					</xsl:choose>
				</accepted>
				<status>
					<xsl:choose>
						<xsl:when test="(itemId = 'BUTTER') and (quantity &lt;= 200)">
							Order Accepted
						</xsl:when>
						<xsl:when test="itemId != 'BUTTER'">
							No Such Item:
							<xsl:value-of select="itemId" />
						</xsl:when>
						<xsl:when test="quantity &gt; 200">
							Not Enough Stock
						</xsl:when>
						<xsl:otherwise>
							UNKNOWN
						</xsl:otherwise>
					</xsl:choose>
				</status>
			</xsl:for-each>
		</orders:orderAck>
	</xsl:template>
</xsl:stylesheet>
----


== SwitchYard - Transformations - Transformations in a Camel component

Transformations can be done in Camel component. Camel provides with many means of doing tranformations: 

=== XSLT

[source,java]
----
   public void configure() throws Exception {
      from("direct:start")
            .to("xslt:book.xslt");
   }
----

==== XQuery

[source,java]
----
   public void configure() throws Exception {
      from("direct:start")
         .transform(xquery("<books>{for $x in /bookstore/book where $x/price>30 order by $x/title return $x/title}</books>"));
   }
----

=== JAXB

[source,java]
----
    public void configure() throws Exception {
        DataFormat myJaxb = new JaxbDataFormat("org.camelcookbook.transformation.myschema");

        from("direct:marshal")
            .marshal(myJaxb)
            .to("mock:marshalResult");

        from("direct:unmarshal")
            .unmarshal(myJaxb)
            .to("mock:unmarshalResult");
    }
----

=== JSON

[source,java]
----
    public void configure() throws Exception {
        from("direct:marshal")
            .marshal().json()
            .to("mock:marshalResult");

        from("direct:unmarshal")
            .unmarshal().json()
            .to("mock:unmarshalResult");
    }
----

=== XMLJSON

[source,java]
----
    public void configure() throws Exception {
        from("direct:marshal")
            .marshal().xmljson()
            .to("mock:marshalResult");

        from("direct:unmarshal")
            .unmarshal().xmljson()
            .to("mock:unmarshalResult");

        XmlJsonDataFormat xmlJsonFormat = new XmlJsonDataFormat();
        xmlJsonFormat.setRootName("bookstore");
        xmlJsonFormat.setElementName("book");
        xmlJsonFormat.setExpandableProperties(Arrays.asList("author", "author"));

        from("direct:unmarshalBookstore")
            .unmarshal(xmlJsonFormat)
            .to("mock:unmarshalBookstoreResult");
    }
----

See https://github.com/CamelCookbook/camel-cookbook-examples/tree/master/camel-cookbook-transformation[Camel developer cookbook Transformation Chapter source code]

== SwitchYard - Transformations - Transformations in a Camel component (II)
Transformations can be done in a variety of ways in camel:

[width="100%", cols="asciidoc,"]
|=======
|http://camel.apache.org/content-enricher.html[Content Enricher EIP] |image:transformers/ContentEnricher.gif[Content Enricher EIP]
|http://camel.apache.org/message-translator.html[Message Translator EIP] |image:transformers/MessageTranslator.gif[Message Translator EIP]
|http://camel.apache.org/content-filter.html[Content Filter EIP] |image:transformers/ContentFilter.gif[Content Filter EIP]
|http://camel.apache.org/normalizer.html[Normalizer EIP] |image:transformers/Normalizer.gif[Normalizer EIP]
|http://camel.apache.org/templating.html[Templating]|
|=======


== SwitchYard - Transformations - Other

 TODO: Create this

== SwitchYard - Validations (Java validations, XML Validation)
Validation feature provides a functionality for message content validation.

* Different implementations for validators:
** Java
** XML
** Other (to be coming...)

We often need to perform message validation before processing its data in service logic, but implementing the validation logic directly in the consumer or provider pollutes the service logic and can lead to tight coupling.  SwitchYard allows for the validation logic to be declared outside the service logic and injected into the mediation layer at runtime.

Validation of message content is specified in the descriptor of your SwitchYard application (switchyard.xml). The qualified name of the type being validated name is defined along with the validator implementation.

== SwitchYard - Java validations

Implementing Java validation is just a matter of creating a new (Java) Validator on the SwitchYard application:

image::switchyard/validators/new_validator.png[New validator]

And selecting type you want to validate and implementing class or bean.

image::switchyard/validators/java_validator.png[Create a Java validator]

It will create the appropiate configuration in the switchyard.xml file:

image::switchyard/validators/validator_switchyard_xml.png[Validator defined in switchyard.xml file]

And the appropiate class/bean needs to be created (manually), with the correspongin annotations (*@Named* and *@Validator*):

image::switchyard/validators/annotated_validator.png[Annotated validator]

Validation methods should return an instance of *import org.switchyard.validate.ValidationResult*.

There is a helper class for validation called: *org.switchyard.validate.BaseValidator* that provides with methods for *validResult()* and *invalidResult(...)*

== SwitchYard - XML validations

 TODO: Create this

== SwitchYard - Properties

 TODO: Create this

== SwitchYard - Environment Properties

Environment properties allow you to replace any attribute or element value in switchyard.xml with a property from the runtime environment. The syntax for a replaced token is "${varName}" where "varname" is your property name. The configuration layer in SwitchYard is configured with instances of PropertyResolver, which are used to resolve the value of a property based on its name.

=== Where to define Environment Properties
Property values are resolved from the following locations:

* System properties passed by -D option of Java VM like "-Dproperty.name=property.value"
* System environment variables, referenced with an "env." prefix, for example: env.PATH
* Unit test properties
* JBoss AS7 properties, including access into the SecurityVault
* Domain properties in switchyard.xml
* SCA property definitions in the composite or component

=== Property overriding
SwitchYard property resolver scans the property in following order.

* System properties and System environment variables
* Unit test properties
* JBoss AS7 properties
* Domain properties
* SCA composite properties
* SCA component properties

 You can specify the default property value with "${propertyName:defaultValue}" syntax where "propertyName" is the name of property.

=== Property escaping
Sometimes, the desired value for a property needs to be in the same "dollar curly" syntax which triggers SwitchYard's property substitution. This can be problematic because in these cases, you want SwitchYard to leave the configured value alone. To accomplish this, use a "double dollar curly" syntax instead.

[source,xml]
----
<foo value="${prop}"/>
<bar value="$${prop}"/>
----

Assuming the value "prop" is a resolvable property (say, equal to "test"), the value attribute of the foo element will be that value ("test").  However, the value attribute of the bar element will be "${test}" (with one dollar sign).

== SwitchYard - Implementation Properties
Implementation properties allow you to inject one or more property values into a service implementation.

This is based on the property support in the SCA assembly spec. Since the property is injected into service implementation logic, the injection mechanism itself is unique to each implementation type. 

* *Java*: injected using @Property into a CDI bean
* *Camel*: wired into Camel properties component and accessible in a Camel route using Camel's own varName property notation
* *BPEL*: mapped into process variables via an <assign> with using resolveProperty() XPath custom function
* *BPMN 2*: inserted into process variables by data input associations
* *Drools*: available in a global map

 TODO: Create this

== SwitchYard - Implementation Properties - Bean
Implementation properties represent environmental properties that you have defined in the SwitchYard application descriptor (switchyard.xml) for your bean implementation.  To access these properties, simply add an @Property annotation to your bean class identifying the property you want to inject. The following example demonstrates injection of a "user.name" property:

[source,java]
----
@Service(SimpleService.class)
public class SimpleServiceBean implements SimpleService {
 
   @Property(name="user.name")
   private String name;
 
   public String sayHello(String message) {
      return "Hello " + name + ", I got a message: " + message;
   }
}
----

== SwitchYard - Implementation Properties - Camel
SwitchYard integrates with the Properties Component in Camel to make system and application properties available inside your route definitions. You can inject properties into your camel route using "{{propertyName}}" expression where "propertyName" is the name of the property.

[source,xml]
----
<route xmlns="http://camel.apache.org/schema/spring" id="CamelTestRoute">
   <log message="ItemId [${body}]"/>
   <to uri="switchyard://WarehouseService?operationName=hasItem"/>
   <log message="Title Name [${body}]"/>
   <log message="Properties [{{user.name}}]"/>
</route>
----

== SwitchYard - Invocation Properties
It is information relative to the invocation or current execution. It is carried along the SwitchYard Context.

== SwitchYard - Invocation Properties - Bean Components
There can be situations where you need to access contextual information like message headers (e.g. received file name) in your implementation. To facilitate this, the Bean component allows you to access the SwitchYard Exchange Context instance associated with a given Bean Service Operation invocation. To get a reference to the Context, simply add a Context property to your bean and annotate it with the CDI @Inject annotation.

[source,java]
----
@Service(SimpleService.class)
public class SimpleServiceBean implements SimpleService {
 
@Inject
private Context context;
 
public String sayHello(String message) {
        System.out.println("*** Funky Context Property Value: " + context.getPropertyValue("funkyContextProperty"));
        return "Hi there!!";
    }
}
----

 The Context interface allows your bean logic to get and set properties in the context.  Note that you can only make calls on the Context instance within the scope of one of the Service Operation methods. Invoking it outside this scope will result in an UnsupportedOperationException being thrown.

== SwitchYard - Policies (transaction, )
Policy allows you to control the runtime behavior of a service in a declarative manner, independent of the service implementation and binding details. 

* Configuring policy
* Interaction Policy
* Implementation Policy

 TODO: Create this

== Transaction Policy

 TODO: Create this

== Transaction Interaction Policy

 TODO: Create this

== Transaction Implementation Policy

 TODO: Create this

== Security Policy

 TODO: Create this

== Security Interaction Policy

 TODO: Create this

== Security Implementation Policy

 TODO: Create this

== SwitchYard - Security
SwitchYard services can be secured by:

1. Specifying a list of security policies that are required for that service.
2. Configuring application-level security processing details for the services within a domain.
3. Configuring system-level security processing details.
4. Storing sensitive information, such as passwords, in the JBoss AS password vault.

 TODO: Create this

== SwitchYard - Clustering
There are two fundamental building blocks to the clustering support in SwitchYard:

* *Shared Runtime Registry*: a shared, distributed runtime registry which allows individual instances to publish and query service endpoint details.
* *Remote Communication Channels*: an internal communication protocol used to allow a service client to invoke a service hosted in a remote instance.

image::switchyard/clustering.jpg[Clustering]

The runtime registry is backed by a replicated Infinispan cache.  Each instance in a cluster points to the same replicated cache.  When a node joins a cluster, it immediately has access to all remote service endpoints published in the registry.  If a node leaves the cluster due to failure or shutdown, all service endpoint registrations are immediately removed for that node.  The registry is not persisted, so manually clean-up and maintenance is not required.  Note that the shared registry is a runtime registry and not a publication registry, which means the registry's lifecycle and state is tied to the current state of deployed services within a cluster.  This is in contrast to a publication registry (e.g. UDDI), where published endpoints are independent from the runtime state of the ESB.

The communications channel is a private intra-cluster protocol used by instances to invoke a remote service.  The channel is currently based on HTTP, but this may change in the future and should be considered a transparent detail of the clustering support in SwitchYard.

 TODO: REVIEW this

== SwitchYard - Configuring Clustering
Clustering support is light on configuration and should work out of the box.  The only real requirements are using a shared Infinispan cache for the runtime registry and indicating which services are clustered in your application config (switchyard.xml).  By default, SwitchYard uses the default cache in the "cluster" cache container which comes pre-defined in your standalone-ha.xml.  Unless you have specific requirements to use a different cache or separate cache configuration, just stick with the default.

Applications take advantage of clustering by explicitly identifying which services should be clustered in the application's descriptor (switchyard.xml).  You can control which services in your application will be published in the cluster's runtime registry and which references can be resolved by clustered services.  To enable a service to be published in the cluster's runtime registry, promote the service in your application and add a <binding.sca> with clustering enabled to it.

[source,xml]
----
<sca:service name="Goodbye" promote="GoodbyeBean/Goodbye">   
   <sca:interface.java interface="com.example.Goodbye"/>
   <sca:binding.sca sy:clustered="true"/>
</sca:service>
----

Consuming services in a cluster follows the same configuration approach, but applies to references in your application.  To invoke a service in a cluster, promote the reference and add an SCA binding with clustering enabled.

[source,xml]
----
<sca:reference name="Goodbye" multiplicity="0..1" promote="GreetingBean/Goodbye">
   <sca:interface.java interface="com.example.Goodbye"/>
   <sca:binding.sca sy:clustered="true"
</sca:reference>
----

 TODO: REVIEW this

== SwitchYard - Using Clustering
To create a cluster of SwitchYard instances, start two or more AS 7 instances with a shared Infinispan cache.  Out-of-the-box configuration in standalone-ha.xml should be sufficient:

[source,bash]
----
# start instance 1
node1> bin/standalone.sh -c standalone-ha.xml -Djboss.node.name=node1
# start instance 2
node2> bin/standalone.sh -c standalone-ha.xml -Djboss.node.name=node2 -Djboss.socket.binding.port-offset=1000
----

Once the instances are up, you can deploy applications independently to each instance.  A homogeneous cluster would have identical applications deployed on each node.  A heterogeneous cluster will have different applications and services deployed on each instance. For testing purposes, it's easiest to deploy a consumer application to one instance and a provider application to another.

 TODO: REVIEW this

== SwitchYard - RemoteInvoker

 TODO: Create this

== SwitchYard - Serialization

 TODO: Create this

== SwitchYard - Extensions

 TODO: Create this

== SwitchYard - Use cases:
 * Asynchronous processing: How to build, deploy, and manage a simple Camel route that communicates with ActiveMQ queues
 * Synchronous processing: How to build, deploy, and manage a simple service

 TODO: Create this

== SwitchYard - Debugging an application
 * Message tracing
 * Exchange interceptors
 * Auditing exchanges

 TODO: Create this

== SwitchYard - Testing SwitchYard application
SwitchYard provides classes to help you do unit tests with JUnit4 testing framework. 

== SwitchYardRunner
In order to take advantage of the test support in SwitchYard, ensure that your unit test is annotated with the SwitchYardRunner JUnit test Runner class. 

The SwitchYardRunner creates and starts an embedded runtime for each test method.

After the embedded runtime starts, the project containing the test is packaged as a SwitchYard application and deployed to it.

An instance of the SwitchYardTestKit class is injected into the test when a property of type SwitchYardTestKit is declared in the test.

This instance represents the runtime state of the deployed SwitchYard test application.

== SwitchYard JUnit example

[source,java]
----
@RunWith(SwitchYardRunner.class)
public class MyServiceTest  {

    private SwitchYardTestKit testKit;

    @Test
    public void testOperation() {
        MyTestServiceHandler service = new MyTestServiceHandler();

        // register the service...
        testKit.registerInOutService("MyService", service);

        // invoke the service and capture the response...
        Message response = newInvoker("MyService")
        .sendInOut("<create>A1234</create>");

        // test the response content by doing an XML comparison with a
        // file resource on the classpath...
        testKit.compareXMLToResource(response.getContent(String.class), 
                                     "/myservice/expected-create-response.xml");
    }

    private class MyTestServiceHandler implements ExchangeHandler {
        // implement methods....
    }
}
----

== SwitchYardTestKit
SwitchYardTestKit represents the runtime state of the deployed SwitchYard test application.

The SwitchYardTestKit class provides a set of utility methods for performing all sorts of deployment configuration and test operations.

This class gets injected when we use SwitchYardRunner and we have declared an instance of *SwitchYardTestKit* type.

We do not need to add injection annotation to this type.


== SwitchYardTestCaseConfig
The SwitchYardTestCaseConfig annotation is optional.

You can use it control the behavior of the SwitchYardRunner:

=== config 

* Allows the specification of a SwitchYard XML configuration file (switchyard.xml) for the test.
* The SwitchYardRunner will attempt to load the specified configuration from the classpath.
* If it fails to locate the config on the classpath, it will then attempt to locate it on the file system (e.g. within the project structure).

=== mixins

* Enables you to add specific testing tools to your test case.
* Each TestMixIn is a composition-based method that provides customized testing tools for service implementations, gateway bindings, and transformers.
* When a TestMixIn is annotated on a test class, the SwitchYardRunner handles all the initialization and cleanup (lifecycle) of the TestMixIn instances.
* It is also possible to manually create and manage TestMixIn instances within your test class if you are not using the SwitchYardRunner.

=== scanner

* Enables you to add classpath scanning as part of the test lifecycle. This adds the same Scanner behavior as the one available with the SwitchYard maven build plugin.
* It allows the scanning to take place as part of the test lifecycle.
* You may need to add Scanners if you want your test to run inside your IDE. This is because running your test inside your IDE bypasses the whole maven build process, which means the build plugin does not perform any scanning

== SwitchYardTestCaseConfig example

[source,java]
----
@RunWith(SwitchYardRunner.class)
@SwitchYardTestCaseConfig(config = "testconfigs/switchyard-01.xml", mixins = {CDIMixIn.class}, scanners = {BeanSwitchYardScanner.class, TransformSwitchYardScanner.class})
public class MyServiceTest  {

    @Test
    public void testOperation() {
        newInvoker("OrderService")
        .operation("createOrder")
        .sendInOnly("<order><product>AAA</product><quantity>2</quantity></order>");
    }
}
----

== mixins
The TestMixIn feature allows you to selectively enable additional test functionality based on the capabilities of your application.

To include MixIn support in your application, you must include a Maven dependency in your application's pom.xml:

[source,xml]
----
<dependency>
    <groupId>org.switchyard.components</groupId>
    <artifactId>switchyard-component-test-mixin-name</artifactId>
    <version>release-version</version> <!-- e.g. "1.0" -->
    <scope>test</scope>
</dependency>
----

== Available mixins

* *CDIMixIn* (switchyard-component-test-mixin-cdi): boostraps a stand-alone CDI environment, automatically discovers CDI beans, registers bean services, and injects references to SwitchYard services.
* *HTTPMixIn* (switchyard-component-test-mixin-http): client methods for testing HTTP-based services.
* *SmooksMixIn* (switchyard-component-test-mixin-smooks): stand-alone testing of any Smoooks transformers in your application.
* *HornetQMixIn* (switchyard-component-test-mixin-hornetq): bootstraps a stand-alone HornetQ server and provides utility methods to interact with it for testing purpose. It can be also used to interact with remote HornetQ server.
* *JCAMixIn* (switchyard-component-test-mixin-jca): bootstraps a embedded IronJacamar JCA container and provides utility methods to interact with it for testing purpose. It has a MockResourceAdapter feature to simulate the SwitchYard application behavior without connecting to the real EIS systems. JCAMixIn has been deprecated. It will be removed from the distribution in the future. JCA testing capabilities also provide wiht a *TransactionMixIn*.
* *NamingMixIn* (switchyard-component-test-mixin-naming): provides access to naming and JNDI services within an application.
* *PropertyMixIn* (switchyard-test): provides ability to set test values to properties that are used within the configuration of the application


== Available scanners

* *BeanSwitchYardScanner*: Scans for CDI Bean Service implementations.
* *TransformSwitchYardScanner*: Scans for Transformers.
* *BpmSwitchYardScanner*: Scans for @Process, @StartProcess, @SignalEvent and @AbortProcessInstance annotations.
* *RouteScanner*: Scans for Camel Routes.
* *RulesSwitchYardScanner*: Scans for @Rule annotations.

== Enabling test support
Adding test support to your SwitchYard application is simply a matter of adding a dependency to the switchyard-test module in your application's pom.xml.

[source,xml]
----
<dependency>
    <groupId>org.switchyard</groupId>
    <artifactId>switchyard-test</artifactId>
    <version>[release-version]</version> <!-- e.g. "1.1.1-p5-redhat-1" -->
    <scope>test</scope>
</dependency>
----
Note: camel dependency version is 2.10.0.redhat-60024

In addition to a dependency on the core test framework, you might want to take advantage of MixIns in your test classes.

== Metadata and Support Class Injections
Some support classes can be injected into a SwitchYard Junit test by SwitchYardRunner.

== TestKit Injection
Injecting the SwitchYardTestKit instance into the test at runtime is simply a case of declaring a property of that type in the test class.

[source,java]
----
@RunWith(SwitchYardRunner.class)
public class MyServiceTest  {

    private SwitchYardTestKit testKit;

    // implement test methods...
}
----

== Deployment Injection
You can inject the deployment instance by declaring a property of the type Deployment.

[source,java]
----
@RunWith(SwitchYardRunner.class)
public class MyServiceTest  {

    private Deployment deployment;

    // implement test methods...
}
----

== SwitchYardModel Injection
You can inject the SwitchYardModel instance by declaring a property of the type SwitchYardModel.

[source,java]
----
@RunWith(SwitchYardRunner.class)
public class MyServiceTest  {

    private SwitchYardModel model;

    // implement test methods...
}
----

== ServiceDomain Injection
You can inject the ServiceDomain instance by declaring a property of the type ServiceDomain.

[source,java]
----
@RunWith(SwitchYardRunner.class)
public class MyServiceTest  {

    private ServiceDomain serviceDomain;

    // implement test methods...
}
----

== TransformerRegistry Injection
You can inject the TransformerRegistry instance by declaring a property of the type TransformerRegistry.

[source,java]
----
@RunWith(SwitchYardRunner.class)
public class MyServiceTest  {

    private TransformerRegistry transformRegistry;

    // implement test methods...
}
----

== TestMixIn Injection
You can inject the TestMixIn Injection instance by declaring a property of the type TestMixIn Injection.

[source,java]
----
@RunWith(SwitchYardRunner.class)
@SwitchYardTestCaseConfig(mixins = {CDIMixIn.class, HTTPMixIn.class})
public class MyServiceTest  {

    private CDIMixIn cdiMixIn;
    private HTTPMixIn httpIn;

    // implement test methods...
}
----

== PropertyMixIn Injection
PropertyMixIn instances are injected like any other TestMixIn type.

NOTE: You must set any properties you wish to use on the MixIn before deployment in order for them to be useed. To do so, use of the *@BeforeDeploy* annotation.

[source,java]
----
@RunWith(SwitchYardRunner.class)
@SwitchYardTestCaseConfig(mixins = {CDIMixIn.class, PropertyMixIn.class, HTTPMixIn.class})
public class MyServiceTest  {

    private PropertyMixIn propMixIn;
    private HTTPMixIn httpMixIn;

    @BeforeDeploy
    public void setTestProperties() {
        propMixIn.set("soapPort", Integer.valueOf(18002));
    }

    // implement test methods...
}
----

== Invoker Injection
To inject Service Invoker instances, declare properties of the type Invoker and annotate them with @ServiceOperation. (Note the annotation value is a dot-delimited Service Operation name of the form [service-name].[operation-name].)

[source,java]
----
@RunWith(SwitchYardRunner.class)
@SwitchYardTestCaseConfig(config = "testconfigs/switchyard-01.xml")
public class MyServiceTest  {

   @ServiceOperation("OrderService.createOrder")
   private Invoker createOrder;

   @Test
   public void test_createOrder() {
      createOrder.sendInOnly("<order><product>AAA</product><quantity>2</quantity></order>");
   }
}
----

== TIPS: Using harmcrest to assert
Hamcrest is a framework for writing matcher objects allowing 'match' rules to be defined declaratively.

We can use Hamcrest's *assertThat* construct and the standard set of matchers, both of which can be statically imported.

[source,java]
----
import static org.hamcrest. MatcherAssert .assertThat;
import static org.hamcrest. Matchers .*;
----

Hamcrest comes with a library of useful matchers. Here are some of the most important ones.

* Core
** anything: always matches, useful if you don't care what the object under test is
** describedAs: decorator to adding custom failure description
** is: decorator to improve readability
* Logical
** allOf: matches if all matchers match, short circuits (like Java &&)
** anyOf: matches if any matchers match, short circuits (like Java ||)
** not: matches if the wrapped matcher doesn't match and vice versa
* Object
** equalTo: test object equality using Object.equals
** hasToString: test Object.toString
** instanceOf, isCompatibleType: test type
** notNullValue, nullValue: test for null
** sameInstance: test object identity
* Beans
** hasProperty: test JavaBeans properties
* Collections
** array: test an array's elements against an array of matchers
** hasEntry, hasKey, hasValue: test a map contains an entry, key or value
** hasItem, hasItems: test a collection contains elements
** hasItemInArray: test an array contains an element
* Number
** closeTo: test floating point values are close to a given value
** greaterThan, greaterThanOrEqualTo, lessThan, lessThanOrEqualTo: test ordering
* Text
** equalToIgnoringCase: test string equality ignoring case
** equalToIgnoringWhiteSpace: test string equality ignoring differences in runs of whitespace
** containsString, endsWith, startsWith: test string matching

== Invoke a component service
In order to invoke a component service, a invoker must be injected for certain ServiceOperation.

When injecting a service operation, we must specify it in *"[service_name].[operation_name]"* notation.

[source,java]
----
import org.switchyard.test.Invoker;
...

@RunWith(SwitchYardRunner.class)
@SwitchYardTestCaseConfig(mixins = CDIMixIn.class)
public class ExampleServiceTest {

   @ServiceOperation("ExampleService.submitOperation")
   private Invoker submitOperation;

   @Test
   public void testOK() throws Exception {
      ParamIn testParam = new ParamIn().set...(...);

      ParamOut result = submitOperation.sendInOut(testParam)
                                       .getContent(ParamOut.class);

      Assert....
   }

   @Test
   public void testForFault() throws Exception {
      ParamIn testParam = new ParamIn().set...(...);

      try{
         // This method invocation should throw a fault
         ParamOut result = submitOperation.sendInOut(testParam)
                                          .getContent(ParamOut.class);

         Assert.fail();
      } catch (InvocationFaultException ifex){
         Assert.... // Assert for correct type of exception
      }
   }
}
----

== TIP Checking for exceptions
An invocation to a service operation can throw a *InvocationFaultException* whenever the method should throw a fault. So catching this exception is similar to validating for the fault being trhown. We will check against original exception, checking the type of the InvocationFaultException

[source,java]
----
ifex.isType(MyOriginalException.class)
----

Or we can use the provided functionality by JUnit setting the expected exception in the test

[source,java]
----
@Test(expected=org.switchyard.test.InvocationFaultException.class)
----

== Use SwitchYardTestKit utility methods to ease testing
TestKit provides with a set of utility methods to ease validations and some common operations that are performed on test classes.

* Access to underlyings
** *getTestInstance*:
** *getActivators*:
** *getDeployment*:
** *getServiceDomain*:
** *createQName*:

* Service manipulation
** *registerInOutService*:
** *registerInOnlyService*:
** *removeService*:
** *replaceService*:

* Invocation
** *newInvoker*:

* Transformations
** *addTransformer*:
** *newTransformer*:
** *registerTransformer*:

* MixIns
** *getMixIns*:
** *getMixIn*:

* Dependencies
** *getRequiredDependencies*:
** *getOptionalDependencies*:

* Resources
** *getResourceAsStream*:
** *readResourceBytes*:
** *readResourceString*: Reads a resource (file) form the classpath
** *readResourceDocument*:

* Configruation
** *loadSwitchYardModel*:
** *loadConfigModel*:

* XML Comparisson
** *compareXMLToResource*: Compares a XML in string format with a XML file in the classpath.
** *compareXMLToString*:

* Tracing
** *traceMessages*: enables message tracing for the application under test.

== org.switchyard.test.MockHandler

TODO: Document Mock Handlers

== TIP Test for transformations in component service
When we test a component invocation, we can test for the appropiate transformation with additional methods on the invocation, for the input transformation as well as for the output transformation:

[source,java]
----
...

@ServiceOperation("ExampleService.submitOperation")
private Invoker serviceOperationInvocation;

@Test
public void testForInputTransformation() throws Exception {
   ParamOut result =  serviceOperationInvocation
                        .inputType(
                           QName.valueOf("{urn:com.example:service:1.0"}submitOperation))
                        .sendInOut(....)
                        .getContent(ParamOut.class);
   Assert....  // Assert that result is OK, so transformation was OK
}

@Test
public void testForOutputXMLTransformation() throws Exception {
   ParamIn testParam = new ParamIn().set...(...);

   ParamOut result = serviceOperationInvocation
                        expectedOutputType(
                           QName.valueOf("{urn:com.example:service:1.0"}submitOperationResponse))
                     .sendInOut(testParam)
                     .getContent(Element.class); // Expect XML Element from transformation

   XMLAssert....  // Assert that result is what is expected
}
----
NOTE: We can use XMLUnit and XMLAssert from *org.custommonkey.xmlunit* to ease validations.

== TIP Test for transformations in component service using HTTPMixIn
NOTE: You have to add the TransformSwitchYardScanner scanner

[source,java]
----
@RunWith(SwitchYardRunner.class)
@SwitchYardTestCaseConfig(
        config = SwitchYardTestCaseConfig.SWITCHYARD_XML,
        scanners = TransformSwitchYardScanner.class,
        mixins = {CDIMixIn.class, HTTPMixIn.class})
public class WebServiceTest {

   private HTTPMixIn httpMixIn;

   @Test
   public void invokeOrderWebService() throws Exception {
      // Use the HttpMixIn to invoke the SOAP binding endpoint with a SOAP input
      // (from the test classpath) and compare the SOAP response to a 
      // SOAP response resource (from the test classpath)...
      httpMixIn.setContentType("application/soap+xml");
      httpMixIn.postResourceAndTestXML("http://localhost:18001/quickstart/OrderService", 
                                       "/xml/soap-request.xml", 
                                       "/xml/soap-response.xml");
   }
}
----

== TIP Test for validations in component service
When we test a component invocation, validations will be tested (as were tested transformations) with an invocation to the TestInvoker, as shown in the previous example.

[source,java]
----
...

@ServiceOperation("ExampleService.submitOperation")
private Invoker serviceOperationInvocation;

@Test
public void testForMessageValidation() throws Exception {
   ParamOut result =  serviceOperationInvocation
                     .inputType(
                           QName.valueOf("{urn:com.examaple:service:1.0"}submitOperation))
                     .sendInOut(....)
                     .getContent(ParamOut.class);
   Assert....  // Assert that result is OK, so validation was OK
}
----

== TIP Test for validations in component service using HTTPMixin
You can also use HTTPMixIn for testing validations.

NOTE: You have to add the ValidateSwitchYardScanner scanner

[source,java]
----
@RunWith(SwitchYardRunner.class)
@SwitchYardTestCaseConfig(
        config = SwitchYardTestCaseConfig.SWITCHYARD_XML,
        scanners = ValidateSwitchYardScanner.class,
        mixins = {CDIMixIn.class, HTTPMixIn.class})
public class WebServiceTest {

   private HTTPMixIn httpMixIn;

   @Test
   public void invokeOrderWebService() throws Exception {
      // Use the HttpMixIn to invoke the SOAP binding endpoint with a SOAP input
      // (from the test classpath) and compare the SOAP response to a 
      // SOAP response resource (from the test classpath)...
      httpMixIn.setContentType("application/soap+xml");
      httpMixIn.postResourceAndTestXML("http://localhost:18001/quickstart/OrderService", 
                                       "/xml/soap-request.xml", 
                                       "/xml/soap-response.xml");
   }
}
----

== TIP Mock a service, component or reference
Sometimes it is useful to mock a component, so it is never invoked for the shake of a test. 
For this, SwitchYardTestKit provides with the ability of adding, replacing or removing services.

[source,java]
----
    // replace existing implementation for testing purposes
    testKit.removeService("MyService");
    final MockHandler myService = testKit.registerInOnlyService("MyService");

    .... // Invoke the service under test

    // Assert what has arrived ath the mocked service
    final LinkedBlockingQueue<Exchange> recievedMessages = myService.getMessages();
    assertThat(recievedMessages, is(notNullValue()));

    final Exchange recievedExchange = recievedMessages.iterator().next();
    assertThat(recievedExchange.getMessage().getContent(String.class), is(equalTo(...)));

----

When we want to assert what has arrived/produced the MockHandler, we can get:

* getMessages(): This provides with the list of received messages.
* getFaults(): This provides with the list of produced faults.

Sometimes service is InOut, so we need to mock a response. There are four options:

* forwardInToOut()
* forwardInToFault()
* replyWithOut(Object)
* replyWithFault(Object)

[source,java]
----
    final MockHandler mockHandler = testKit.registerInOutService("MyService");
    mockHandler.forwardInToOut();
----

We can also instruct the MockHandler to wait for certain message.

* waitForOkMessage()
* waitForFaultMessage()

It will wait for 5 seconds (default) unless instructed to wait for a different period with *setWaitTimeout(milis)*

== TIP Mock a service for more than 1 method invocation
There are some cases where the service we are mocking is being called two times in the context of a single unit test,
maybe multiple calls to the same method, or to different methods.
For this particular case, we can register an *ExchangeHandler* with the mock,
while registering and replacing the original service, that will get the message, and where
we will have to put some logic to deal with this scenario.

[source,java]
----
    testKit.replaceService(qname, new ExchangeHandler() {

        @Override
        public void handleMessage(Exchange arg0) throws HandlerException {
            // Here logic to handle with messages
        }

        @Override
        public void handleFault(Exchange arg0) throws HandlerException {
            // Here logic to handle with faults
        }
    });
----

If this ExchangeHandler needs to be reused, of course, can be made a named class (not anonymous).

== TIP MockHandler for testing one method multiple invocations
In this scenario, the ExchangeHandler needs to keep track of which invocation number it was in case has to answer with different messages

[source,java]
----
testKit.replaceService(qname, new ExchangeHandler() {
   int call=1;

   @Override
   public void handleMessage(Exchange exchange) throws HandlerException {
      if (call++ == 1){ // First call
         // Do whatever wants to be done as result of this operation call, 
         // and return the expected output
         Result result = ...; / Result is return type for operation store
         exchange.send(exchange.createMessage().setContent(result));
      }else if (call++ == 2){ // Second call
         // Do whatever wants to be done as result of this operation call, 
         // and return the expected output
         Result result = ...; / Result is return type for operation store
         exchange.send(exchange.createMessage().setContent(result));
      }else{
         throw new HandlerException("This mock should not be called more than 2 times");
      }
   }

   @Override
   public void handleFault(Exchange exchange) throws HandlerException {
      // Here logic to handle with faults
   }
});
----

== TIP MockHandler for testing different methods
In this scenario, the ExchangeHandler used will have to check for operation name, to know which method is being invoked.


[source,java]
----
testKit.replaceService(qname, new ExchangeHandler() {

   @Override
   public void handleMessage(Exchange exchange) throws HandlerException {
      if (exchange.getContract().getProviderOperation().getName().equals("store")){
         // Do whatever wants to be done as result of this operation call, 
         // and return the expected output
         Result result = ...; / Result is return type for operation store
         exchange.send(exchange.createMessage().setContent(result));
      }else if (exchange.getContract().getProviderOperation().getName().equals("getId")){
         // Do whatever wants to be done as result of this operation call, 
         // and return the expected output
         exchange.send(exchange.createMessage().setContent(1)); // This operation returns a Int
      }else{
         throw new HandlerException("No operation with that name should be executed");
      }
   }

   @Override
   public void handleFault(Exchange exchange) throws HandlerException {
      // Here logic to handle with faults
   }
});
----

== TIP How to add credentials before invoking a Service
When there is a service that uses credentials for routing or logic, we need to inject this credentials also in testing, so we do not need to modify our application logic.
To do so, we can add the required credentials to the invocation before calling the actual service.

NOTE: It is a hack for SwitchYard version 1.1 (https://issues.jboss.org/browse/SWITCHYARD-2031)

[source,java]
----
    protected SecurityContextManager securityMgr;

    @Before
    public void onCreate() {
        securityMgr = new SecurityContextManager(testKit.getServiceDomain());
    }

    ...
    service.operation("deleteEnterprises").sendInOut(addCredentials(message))
                .getContent(DeleteEnterpriseResponse.class);
    ...

    @SuppressWarnings("unchecked")
    private <T> T addCredentials(T request) {
        AuthenticationWrapper wrapper = new AuthenticationWrapper();
        testKit.registerInOutService("AuthenticationWrapper", wrapper);
        QName serviceName = new QName(ObjectFactory.NAME_SPACE, "AuthenticationWrapper");
        Invoker service = new Invoker(testKit.getServiceDomain(), serviceName);
        return (T) service.operation("").sendInOut(request).getContent();
    }

    private class AuthenticationWrapper implements ExchangeHandler {

       @Override
        public void handleMessage(Exchange exchange) throws HandlerException {
            Set<Credential> credentials = new HashSet<Credential>();
            credentials.add(new NameCredential(USERNAME));
            securityMgr.addCredentials(exchange, credentials);
            exchange.send(exchange.getMessage().copy());
        }

        @Override
        public void handleFault(Exchange exchange) {
        }
    }
----

== TIP Invoke a remote service
When a service is published with an SCA binding, we can invoke it remotely with a Remote Invoker.

[source,java]
----
    public static void main(final String[] ignored) throws Exception {
        // Create a new remote client invoker
        RemoteInvoker invoker = new HttpInvoker("http://localhost:8080/switchyard-remote");

        // Create request payload
        ParamIn input = ...;

        // Create the request message
        RemoteMessage message = new RemoteMessage();
        message.setService(new QName(
            "urn:com.example:1.0","MyService"))
            .setOperation("myOperation").setContent(input);

        // Invoke the service
        RemoteMessage reply = invoker.invoke(message);
        if (reply.isFault()) {
            ...
        } else {
            ParamOut output = (ParamOut)reply.getContent();
            ...
        }
    }
----

== Testing a deployed service with HTTPMixin
Whenever we want to test a deployed service, we can use HTTPMixin to create all the required wishtles.

[source,java]
----
@RunWith(SwitchYardRunner.class)
@SwitchYardTestCaseConfig(
        scanners = TransformSwitchYardScanner.class,
        mixins = {CDIMixIn.class, HTTPMixIn.class})
public class WebServiceTest {

    private HTTPMixIn httpMixIn;

    @Test
    public void invokeWebService() throws Exception {
        // Use the HttpMixIn to invoke the SOAP binding endpoint with a SOAP input (from the test classpath)
        // and compare the SOAP response to a SOAP response resource (from the test classpath)...
        httpMixIn.setContentType("application/soap+xml");
        httpMixIn.postResourceAndTestXML("http://localhost:18001/service-context/ServiceName", "/xml/soap-request.xml", "/xml/soap-response.xml");
    }
}
----

Or from a main class:

[source,java]
----
    /**
     * Only execution point for this application.
     * @param ignored not used.
     * @throws Exception if something goes wrong.
     */
    public static void main(final String[] ignored) throws Exception {

        HTTPMixIn soapMixIn = new HTTPMixIn();
        soapMixIn.initialize();

        try {
            String result = soapMixIn.postFile(URL, XML);
            System.out.println("SOAP Reply:\n" + result);
        } finally {
            soapMixIn.uninitialize();
        }
    }
----

== Creating an Embedded WebService to test a component
In some situations we only want to test a component, so we decide to expose it dynamically as a WebService an invoke it.

[source,java]
----
import javax.xml.ws.Endpoint;
...

@RunWith(SwitchYardRunner.class)
@SwitchYardTestCaseConfig(
        config = SwitchYardTestCaseConfig.SWITCHYARD_XML,
        scanners = {TransformSwitchYardScanner.class},
        mixins = {HTTPMixIn.class})
public class CamelSOAPProxyTest {

    private static final String WEB_SERVICE = "http://localhost:8081/MyService";

    private HTTPMixIn _http;
    private Endpoint _endpoint;

    @BeforeDeploy
    public void setProperties() {
        System.setProperty("org.switchyard.component.http.standalone.port", "8081");
    }

    @Before
    public void startWebService() throws Exception {
        _endpoint = Endpoint.publish(WEB_SERVICE, new ReverseService());
    }

    @After
    public void stopWebService() throws Exception {
        _endpoint.stop();
    }

    @Test
    public void testWebService() throws Exception {
        _http.postResourceAndTestXML(WEB_SERVICE, "/xml/soap-request.xml", "/xml/soap-response.xml");
    }
}
----

== Testing a deployed service with HornetQMixIn
Sometimes we need to test an application that has a JMS binding and we want to test with the binding itself. For these use cases, HornetQMixIn comes to the rescue.

HornetQMixIn gets its configuration from 2 files that has to be on the classpath for the test:

*hornetq-configuration.xml*: Contains the configuration for the HornetQ server.

[source,xml]
----
 <configuration xmlns="urn:hornetq">

        <paging-directory>target/data/paging</paging-directory>
        <bindings-directory>target/data/bindings</bindings-directory>
        <persistence-enabled>false</persistence-enabled>
        <journal-directory>target/data/journal</journal-directory>
        <journal-min-files>10</journal-min-files>
        <large-messages-directory>target/data/large-messages</large-messages-directory>
        <security-enabled>false</security-enabled>

        <connectors>
                <connector name="invm-connector">
                        <factory-class>org.hornetq.core.remoting.impl.invm.InVMConnectorFactory</factory-class>
                </connector>
                <connector name="netty-connector">
                 <factory-class>org.hornetq.core.remoting.impl.netty.NettyConnectorFactory</factory-class>
                 <param key="port" value="5545"/>
      </connector>
        </connectors>

        <acceptors>
                <acceptor name="invm-acceptor">
                        <factory-class>org.hornetq.core.remoting.impl.invm.InVMAcceptorFactory</factory-class>
                </acceptor>
                <acceptor name="netty-acceptor">
                        <factory-class>org.hornetq.core.remoting.impl.netty.NettyAcceptorFactory</factory-class>
                        <param key="port" value="5545"/>
                </acceptor>
        </acceptors>

</configuration>
----

*hornetq-jms.xml*: Contains the definition of the connection factories, queues, topics,...

[source,xml]
----
<configuration xmlns="urn:hornetq">

   <connection-factory name="ConnectionFactory">
      <connectors>
        <connector-ref connector-name="invm-connector"/>
      </connectors>

      <entries>
         <entry name="ConnectionFactory"/>
      </entries>
   </connection-factory>

   <queue name="TestRequestQueue">
      <entry name="TestRequestQueue"/>
   </queue>
   <queue name="TestReplyQueue">
      <entry name="TestReplyQueue"/>
   </queue>

</configuration>
----

To use it in test, you only need to get a reference to the MixIn and use the appropiate mixin methods:

[source,java]
----
@RunWith(SwitchYardRunner.class)
@SwitchYardTestCaseConfig(
        config = SwitchYardTestCaseConfig.SWITCHYARD_XML,
        mixins = {CDIMixIn.class, HornetQMixIn.class}
)

public class JmsBindingTest {

    private HornetQMixIn _hqMixIn;


    @Test
    public void testHelloService() throws Exception {
        Session session = _hqMixIn.getJMSSession();
        MessageProducer producer = session.createProducer(HornetQMixIn.getJMSQueue(REQUEST_NAME));
        Message message = _hqMixIn.createJMSMessage(createPayload(NAME));
        producer.send(message);

        MessageConsumer consumer = session.createConsumer(HornetQMixIn.getJMSQueue(REPLY_NAME));
        message = consumer.receive(3000);
        String reply = _hqMixIn.readStringFromJMSMessage(message);
        SwitchYardTestKit.compareXMLToString(reply, createExpectedReply(NAME));
    }

    @Before
    public void getHornetQMixIn() {
        _hqMixIn = _testKit.getMixIn(HornetQMixIn.class);
    }
----

Or testing from a standalone client:

[source,java]
----
   public static void main(final String[] args) throws Exception {

        HornetQMixIn hqMixIn = new HornetQMixIn(false)
                                    .setUser(USER)
                                    .setPassword(PASSWD);
        hqMixIn.initialize();

        try {
            Session session = hqMixIn.getJMSSession();
            final MessageProducer producer = session.createProducer(HornetQMixIn.getJMSQueue(REQUEST_NAME));
            producer.send(hqMixIn.createJMSMessage("<....>");
            System.out.println("Message sent. Waiting for reply ...");

            final MessageConsumer consumer = session.createConsumer(HornetQMixIn.getJMSQueue(REPLY_NAME));
            Message message = consumer.receive(3000);
            String reply = hqMixIn.readStringFromJMSMessage(message);
            System.out.println("REPLY: \n" + reply);
        } finally {
            hqMixIn.uninitialize();
        }

    }
----

== Testing a deployed service with TransactionMixIn
To test your required services with a transaction, we can use TransactionMixIn. TransactionMixIn with combination of CDIMixIn will inject a UserTransaction object when required. If you need explicit access, you can @Inject the UserTransaction object, but if not, it will be injected in SwitchYard's functionalities for you under the covers. This MixIn introduces NamingMixIn for you, as it is a required dependency.

[source,java]
----
@SwitchYardTestCaseConfig(
    config = SwitchYardTestCaseConfig.SWITCHYARD_XML,
    mixins = {CDIMixIn.class, TransactionMixIn.class}
)
public YourClass{
    ....
}
----

And it will bind following objects into the JNDI tree:

* *TransactionManager*: "java:jboss/TransactionManager"
* *UserTransaction*: "java:jboss/UserTransaction"
* *TransactionSynchronizationRegistry*: "java:jboss/TransactionSynchronizationRegistry"

If you need access to the provided objects, you can use the MixIn to get a reference:

[source,java]
----
    private TransactionMixIn transaction;
    ....
    transaction.getUserTransaction();
    transaction.getTransactionManager();
    transaction.getSynchronizationRegistry();
----

This mixin will leave transactional logs in "target/tx-store".

This mixin uses Arjuna Transactions Provider (com.arjuna.ats.jta).

== Testing JPA functionality

TODO:
See: ./quickstarts/camel-jpa-binding/src/test/java/org/switchyard/quickstarts/camel/jpa/binding/CamelJpaBindingTest.java

== Testing in a container with Arquillian

TODO:

== TIP Running REST, SOAP or HTTP endpoint in different ports

For Rest and Http bindings set the following properties in the JUnit test:

[source, java]
----
    @BeforeDeploy
    public void setProperties() {
        System.setProperty("org.switchyard.component.http.standalone.port", "8081");
        System.setProperty("org.switchyard.component.resteasy.standalone.port", "8081"); 
    }
----

For SOAP bindings, set socketAddr in the switchyard.xml

[source,xml]
----
        <service name="OrderService" promote="OrderService">
            <interface.wsdl interface="wsdl/OrderService.wsdl#wsdl.porttype(OrderService)"/>
            <binding.soap xmlns="urn:switchyard-component-soap:config:1.0">
                <wsdl>wsdl/OrderService.wsdl</wsdl>
                <socketAddr>:9091</socketAddr>
                <contextPath>quickstart-bean</contextPath>
            </binding.soap>
        </service>
----

NOTE: You can externilize this properties, and define them in maven to avoid collisions.

WARNING: If you have a running SwitchYard server, and want to do JUnit test for some bindings, some ports may collide. Use this port redefinition to avoid it.

== TIP Testing with a different (reduced) Switchyard configuration file
Use this annotation on the test class:

[source,java]
----
@SwitchYardTestCaseConfig(config = "switchyard-XXXXX.xml", mixins = {.....})
----

And create your reduced switchyard-XXXX.xml within the test/resources folder at the same package level as your test class.

== TIP Selectively enabling activators for a Test
The test framework defaults to a mode where the entire application descriptor is processed during a test run. This means all gateway bindings and service implementations are activated during each test. There are times when this may not be appropriate, so we allow activators to be selectively enabled or disabled based on your test configuration.
In this example, SOAP bindings are excluded from all tests. (This means that SOAP gateway bindings will not be activated when the test framework loads the application.)

[source,java]
----
@RunWith(SwitchYardRunner.class)
@SwitchYardTestCaseConfig(config = "testconfigs/switchyard-01.xml" exclude="soap")
public class NoSOAPTest  {
   ...
}
----

This example includes only CDI bean services as defined in the application descriptor:

[source,java]
----
@RunWith(SwitchYardRunner.class)
@SwitchYardTestCaseConfig(config = "testconfigs/switchyard-02.xml" include="bean")
public class BeanServicesOnlyTest  {
...
}
----

== TIP Testing a camel binding
In an scenario where you are exposing services with a camel binding, you can test it getting the CamelContext and then creating a ProducerTemplate.

[source,java]
----
@RunWith(SwitchYardRunner.class)
@SwitchYardTestCaseConfig(
        config = SwitchYardTestCaseConfig.SWITCHYARD_XML,
        mixins = { CDIMixIn.class })
public class ExampleTest {

    private SwitchYardTestKit testKit;

    @Test
    public void testIntake() throws Exception {
        ServiceDomain domain = testKit.getServiceDomain();
        CamelContext ctx = (CamelContext)domain.getProperty("CamelContextProperty");
        ProducerTemplate producer = ctx.createProducerTemplate();
        producer.sendBody("direct://HelloService", "Message content");
    }
}
----

You can test a service like the one defined below that has a camel binding.

[source,java]
----
<sca:service name="Hello/HelloService" promote="Hello/HelloService">
   <sca:interface.java interface="org.jboss.example.ExampleService"/>
   <camel_1:binding.uri name="camel1" configURI="direct://HelloService"/>
</sca:service>
----

== Preparing procedure for test
Sometimes we need to add some procedures before test is performed. JUnit @Before operation is invoked right after the application is deployed, however, it can't be used if you expect something before deploy. We have @BeforeDeploy annotation for this purpose.

== TIP Testing a Web Service with Policies defined in it or a SOAP CXF interceptor
If you need to do unit testing for a service with policies defined in it, or a custom SOAP cxf interceptor, you will not be able to do it at the moment unless you run the tests against a real "running" container.

== SwitchYard - Advanced topics
 * Distributed transactions in FSW - what is possible and what is not possible (e.g. can a splitter/aggregator ever be transactional)

 TODO: Create this

== RTGov
What is Runtime monitoring 

* Extract the information (events)
* Process the information (analyze)
* Display information (visualize)

What is policy enforcement

* Sync policy
* Async policy

What is SLA

* sla
* situations

For call trace
* ActivityReporter: reports activity to the BAM server. Can be injected with @Inject in a Bean Component. (How can be injected in Camel or any other???) Has methods logError, logWarn, logInfo,...

For policies:
* AbstractExchangeValidator extends ExchangeInterceptor: This class observes exchanges and uses the information to create activity events to be validated
* ExchangeInterceptors allow code to be injected around specific interactions in the core exchange bus via a target definition. Valid targets are documented as constant fields in this interface

InformationProcessor that is based on a set of expressions used to extract relevant data from the supplied information.


image::overlord/rtgov/rtgov_architecture.jpg[RTGov Architecture]

image::overlord/rtgov/policy_Async_Enforcement.jpg[Policy Async Enforcement]

 TODO: Create this


== DTGov

 * App building
 * life-cycle management
 * Deployment
 * Integrating the build/test/deployment process into a maven based build engine

image::overlord/dtgov/soa_governance.png[SOA Governance]

 TODO: Create this

== Development
 
 * JBoss Developer Studio + IS plugins
 * Maven
 * Project structure (single project, multiproject, war, ear,...)

 TODO: Create this


== Operations
 
 * Installation (installer, silent,...)
 * Starting/stopping servers (server services)
 * Users
 * Multinode configuration (Multiple servers in one box
 * Databases
 * Management (Console, CLI, JMX, BPEL Console)
 * Monitoring
 * Troubleshooting

 TODO: Create this

== Architecture - Topologies
* Simple topology (All in one)
* Environmental topology
* Environmental topology with unified governance

== Simple topology (All in one)
This topology deploys all the functions in the same boxes, a set of 2 or more boxes (to have clustering) and it is not recommended as the production approach, but rather for PoC and demoing.

image::fsw/architecture/FSW_deployment_allinone.jpg[FSW Architecture]

This topology is a simple topology and will consist of:

* A cluster of servers for SwitchYard, rtGov + dtGov.
* We will typically front this cluster with a Load Balancer. For this we usually have two options, a Hardware load balancer (typically this is clustered) or an httpd+mod_cluster (usually in an HA manner, A/A or A/P)
* We also have a cluster of databases (amongst those supported by the product) in a clustered way, for HA.

Httpd servers and database servers ca be co-located on the same boxes as the FSW servers, so reducing the required amount of boxes needed for this.

We need to take into account for this topology additional constraints such as:

* Having a separate messaging topology included in the solution and connected from SwitchYard clusters via JMS bridge or ActiveMQ/HornetQ jca adapter.
* Having shared storage for file based type of services

== Environmental topology
This topology deploys every function into every existing environment in a clustered manner per functionality.

image::fsw/architecture/FSW_deployment_environmental.jpg[FSW Architecture]

In every environment we will have:

* A large cluster of servers for SwitchYard (this servers include rtGov client) that will do the service execution.
* We will typically front this cluster with a Load Balancer. For this we usually have two options, a Hardware load balancer (typically this is clustered) or an httpd+mod_cluster (usually in an HA manner, A/A or A/P)
* A cluster of RTGov servers (for HA) that will be doing runtime governance analisys. This cluster will be A/P and accessed through a VIP.
* We also have a cluster of databases (amongst those supported by the product) in a clustered way, for HA.
* A cluster for Design Time Governance that will orchestrate the state of services in that environment. Promotion of artifacts amongst environments will be done manually, and thus the solely purpose of this DTGov cluster in the environment is to provide with the S-RAMP storage capabilities for artifacts and metadata.

Usually these environments (dev, qa, test, stage, preprod, prod,...) will not be the same in terms of size and capabilities, so Development environment tends to be much smaller in terms of number of boxes and capabilities of those boxes (cores/cpus, ram,...).

We need to take into account for this topology additional constraints such as:

* Having a separate messaging topology included in the solution and connected from SwitchYard clusters via JMS bridge or ActiveMQ/HornetQ jca adapter.
* Having shared storage for file based type of services

== Environmental topology with unified governance
This topology deploys clusters of main functions per existing environment and shares a common layer (cluster/environment) for design time governance (DTGov) responsibilities.

image::fsw/architecture/FSW_deployment.jpg[FSW Architecture]

In every environment we will have:

* A large cluster of servers for SwitchYard (this servers include rtGov client) that will do the service execution.
* We will typically front this cluster with a Load Balancer. For this we usually have two options, a Hardware load balancer (typically this is clustered) or an httpd+mod_cluster (usually in an HA manner, A/A or A/P)
* A cluster of RTGov servers (for HA) that will be doing runtime governance analisys. This cluster will be A/P and accessed through a VIP.
* We also have a cluster of databases (amongst those supported by the product) in a clustered way, for HA.
 
Also, we will lie down a shared environment for Design Time Governance that will orchestrate the state of services between the different environments. This environment is one single environment and can be co-located in any of the other environments, and then making advantage of the load balancing and database capabilities already available in that environment.
 
Usually this environments will not be the same in terms of size and capabilities, so Development environment tends to be much smaller in terms of number of boxes and capabilities of those boxes (cores/cpus, ram,...)
 
We need to take into account for this topology additional constraints such as:

* Having a separate messaging topology included in the solution and connected from SwitchYard clusters via JMS bridge or ActiveMQ/HornetQ jca adapter.
* Having shared storage for file based type of services

== Continuous Delivery with FSW
FSW is a great product, and incorporates in the suite a Governance solution for services lifecycle. We usually don't have a clear picture of how to map this product to user requirements, and how to integrate into the customer environments or way of doing things.
What I describe here are some examples of use cases that can be done with DTGov to enable Continuous Delivery of services for a customer. Of course, these are just examples, and every customer/organization will have their specific concerns or tools or way of working, so this process *ALWAYS* needs to be tailored for the customer. But you can use these examples to get into the conversation with the customer.

== Tag Final version after all testing phases
This example here assumes the customer will go through all their testing phases using a "Snapshot" or not "final" version of the artifact, and will tag it as Final just when the artifact is ready to be promoted to the production environment. If testing at some point fails, version will not be bumped.

image::fsw/architecture/DTGov_CD.png[CD with FSW]

. Developer commit/pushes their development to the VCS (Version Control System) they are using (Git, SVN,...)
.. To note that developer will use artifact repository to fetch dependencies. For this example, it will use Nexus for released versions and dtGov for snapshots. (An option can be to have nexus proxy to dtGov for the Snapshots)
. Continuous Integration server fetches latest code from VCS and trigger the execution of the build job that will build and do unit tests on the code. If everything works fine, and all tests pass, it will deploy the generated artifact to DTGov via maven deployment API.
. DTGov will start executing the configured workflow for this kind of service.
.. DTGov can have multiple workflows for different kind of services.
. DTGov will deploy/install/copy the artifact to the target environment with the configured deployment process (Using maven, JBoss cli, file copy or JON)
. Workflow will be in waiting state for the configured used to functional validate the development in the corresponding environment (dev in this example).
. Once the user has validated the development doing the pertinent functional/integration/performance/xxx tests it will approve or reject the task in "DTGov task inbox" which will trigger a finish of the workflow (in case of reject) or continue the workflow (in cse of approve).
.. Bundled workflow (OOTB) sends an email notification with the result of the approval/rejection action taken.
. DTGov workflow continues (in case of approval) and it will deploy to next configured environment, and will create a task for the corresponding user.
. Corresponding user will validate the development, as before.
. User will approve or reject, as before. And so forth with every environment but the last one.
. This example assumes that no automatic deployment can be made to production systems, so part of the workflow, the corresponding to "PROD" environment, will trigger a job in the CI server to release the software (development) and do whatever is appropriate for the task.
. This CI release job, will tag the version in the VCS used.
. It will build the tagged version and it will deploy it to the Artifact repository to the released group for the corresponding project. This way, artifact is accessible.
. Ops guy (team) will get the artifact from the artifact repository
. And it will install it to the "PROD" environment with their "Pass to Production" procedures.

== Tag Final version before all testing phases
 
This example here assumes the customer will go through all their testing phases using a tagged version of the artifact. If testing at some point fails, version will be bumped, and a version that will never get into production will have been produced.

image::fsw/architecture/DTGov_CD-TagFirst.png[CD with FSW]

. Developer commit/pushes their development to the VCS (Version Control System) they are using (Git, SVN,...)
.. To note that developer will use artifact repository to fetch dependencies. For this example, it will use Nexus for released versions and dtGov for snapshots. (An option can be to have nexus proxy to dtGov for the Snapshots)
. Continuous Integration server fetches latest code from VCS and trigger the execution of the build job that will build and do unit tests on the code.
. If everything works fine, the release will be tagged.
. CI server will deploy the generated artifact to DTGov via maven deployment API. DTGov will start executing the configured workflow for this kind of service.
.. DTGov can have multiple workflows for different kind of services.
. DTGov will deploy/install/copy the artifact to the target environment with the configured deployment process (Using maven, JBoss cli, file copy or JON)
. Workflow will be in waiting state for the configured used to functional validate the development in the corresponding environment (dev in this example).
. Once the user has validated the development doing the pertinent functional/integration/performance/xxx tests it will approve or reject the task in "DTGov task inbox" which will trigger a finish of the workflow (in case of reject) or continue the workflow (in cse of approve).
.. Bundled workflow (OOTB) sends an email notification with the result of the approval/rejection action taken.
. DTGov workflow continues (in case of approval) and it will deploy to next configured environment, and will create a task for the corresponding user.
. Corresponding user will validate the development, as before.
. User will approve or reject, as before. And so forth with every environment but the last one.
. This example assumes that no automatic deployment can be made to production systems, so part of the workflow, the corresponding to "PROD" environment, will deploy install the "verified" artifact into the artifact repository (nexus).
. Ops guy (team) will get the artifact from the artifact repository
. And it will install it to the "PROD" environment with their "Pass to Production" procedures.

== DT With FSW CAVEATS
* As I said, there is no golden rule on how to do CI/CD with DTGov. Every SCM (Software Configuration Management) tools has their specifics, and these here presented are shown to be valid with Jenkins as CI server, Git as VCS and Nexus as artifact repository.
* Deployment process can be more complicated than what is here expressed, as SwitchYard doesn't allow yet for domain mode (as of FSW 6.0.0), so installation of the artifact to the environment can be tricky. If using JON, things seem simpler.
* Configuration of development station has to be taken into account and configured accordingly to their artifact repository and to the way of grouping their dependencies.
* Even DTGov can be used as maven server for artifact dependencies, we assume for this workflow that nexus will be the single source of "Final" artifacts, as this simplifies maven "settings.xml" configuration for developers. Nexus can proxy DTGov as a named repository.
* This is an example based on the OOTB workflow with the difference that promotion to Prod environment is not automatic. (As I have yet to see a company that does allow for automatic deployment to prod systems, so I feel this is more realistic).

== Thank you

That's all.

